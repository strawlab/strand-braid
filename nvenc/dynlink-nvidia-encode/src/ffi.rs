/* automatically generated by rust-bindgen 0.55.1 */

#![allow(dead_code,non_upper_case_globals,non_camel_case_types,non_snake_case)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type LONG = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _GUID {
    pub Data1: ::std::os::raw::c_ulong,
    pub Data2: ::std::os::raw::c_ushort,
    pub Data3: ::std::os::raw::c_ushort,
    pub Data4: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
    assert_eq!(
        ::std::mem::size_of::<_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_GUID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GUID>())).Data1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GUID>())).Data2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GUID>())).Data3 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GUID>())).Data4 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data4)
        )
    );
}
pub type GUID = _GUID;
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NV_MEMORY_RANGE {
    pub BaseAddress: *mut ::std::os::raw::c_void,
    pub Length: SIZE_T,
}
#[test]
fn bindgen_test_layout__NV_MEMORY_RANGE() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MEMORY_RANGE>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_MEMORY_RANGE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MEMORY_RANGE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_MEMORY_RANGE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_MEMORY_RANGE>())).BaseAddress as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MEMORY_RANGE),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_MEMORY_RANGE>())).Length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MEMORY_RANGE),
            "::",
            stringify!(Length)
        )
    );
}
pub type NV_MEMORY_RANGE = _NV_MEMORY_RANGE;
pub type PNV_MEMORY_RANGE = *mut _NV_MEMORY_RANGE;
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct tagRECT {
    pub left: LONG,
    pub top: LONG,
    pub right: LONG,
    pub bottom: LONG,
}
#[test]
fn bindgen_test_layout_tagRECT() {
    assert_eq!(
        ::std::mem::size_of::<tagRECT>(),
        16usize,
        concat!("Size of: ", stringify!(tagRECT))
    );
    assert_eq!(
        ::std::mem::align_of::<tagRECT>(),
        4usize,
        concat!("Alignment of ", stringify!(tagRECT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagRECT>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRECT),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagRECT>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRECT),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagRECT>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRECT),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagRECT>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRECT),
            "::",
            stringify!(bottom)
        )
    );
}
pub type RECT = tagRECT;
pub type NVENC_RECT = RECT;
#[doc = " @}"]
pub type NV_ENC_INPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_OUTPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_REGISTERED_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_CUSTREAM_PTR = *mut ::std::os::raw::c_void;
pub mod _NV_ENC_PARAMS_FRAME_FIELD_MODE {
    #[doc = " Input frame encode modes"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Frame mode"]
    pub const NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME: Type = 1;
    #[doc = "< Field mode"]
    pub const NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD: Type = 2;
    #[doc = "< MB adaptive frame/field"]
    pub const NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF: Type = 3;
}
#[doc = " Input frame encode modes"]
pub use self::_NV_ENC_PARAMS_FRAME_FIELD_MODE::Type as NV_ENC_PARAMS_FRAME_FIELD_MODE;
pub mod _NV_ENC_PARAMS_RC_MODE {
    #[doc = " Rate Control Modes"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Constant QP mode"]
    pub const NV_ENC_PARAMS_RC_CONSTQP: Type = 0;
    #[doc = "< Variable bitrate mode"]
    pub const NV_ENC_PARAMS_RC_VBR: Type = 1;
    #[doc = "< Constant bitrate mode"]
    pub const NV_ENC_PARAMS_RC_CBR: Type = 2;
    #[doc = "< Deprecated, use NV_ENC_PARAMS_RC_CBR + NV_ENC_TWO_PASS_QUARTER_RESOLUTION / NV_ENC_TWO_PASS_FULL_RESOLUTION +"]
    #[doc = "lowDelayKeyFrameScale=1"]
    pub const NV_ENC_PARAMS_RC_CBR_LOWDELAY_HQ: Type = 8;
    #[doc = "< Deprecated, use NV_ENC_PARAMS_RC_CBR + NV_ENC_TWO_PASS_QUARTER_RESOLUTION / NV_ENC_TWO_PASS_FULL_RESOLUTION"]
    pub const NV_ENC_PARAMS_RC_CBR_HQ: Type = 16;
    #[doc = "< Deprecated, use NV_ENC_PARAMS_RC_VBR + NV_ENC_TWO_PASS_QUARTER_RESOLUTION / NV_ENC_TWO_PASS_FULL_RESOLUTION"]
    pub const NV_ENC_PARAMS_RC_VBR_HQ: Type = 32;
}
#[doc = " Rate Control Modes"]
pub use self::_NV_ENC_PARAMS_RC_MODE::Type as NV_ENC_PARAMS_RC_MODE;
pub mod _NV_ENC_MULTI_PASS {
    #[doc = " Multi Pass encoding"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Single Pass"]
    pub const NV_ENC_MULTI_PASS_DISABLED: Type = 0;
    #[doc = "< Two Pass encoding is enabled where first Pass is quarter resolution"]
    pub const NV_ENC_TWO_PASS_QUARTER_RESOLUTION: Type = 1;
    #[doc = "< Two Pass encoding is enabled where first Pass is full resolution"]
    pub const NV_ENC_TWO_PASS_FULL_RESOLUTION: Type = 2;
}
#[doc = " Multi Pass encoding"]
pub use self::_NV_ENC_MULTI_PASS::Type as NV_ENC_MULTI_PASS;
pub mod _NV_ENC_EMPHASIS_MAP_LEVEL {
    #[doc = " Emphasis Levels"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Emphasis Map Level 0, for zero Delta QP value"]
    pub const NV_ENC_EMPHASIS_MAP_LEVEL_0: Type = 0;
    #[doc = "< Emphasis Map Level 1, for very low Delta QP value"]
    pub const NV_ENC_EMPHASIS_MAP_LEVEL_1: Type = 1;
    #[doc = "< Emphasis Map Level 2, for low Delta QP value"]
    pub const NV_ENC_EMPHASIS_MAP_LEVEL_2: Type = 2;
    #[doc = "< Emphasis Map Level 3, for medium Delta QP value"]
    pub const NV_ENC_EMPHASIS_MAP_LEVEL_3: Type = 3;
    #[doc = "< Emphasis Map Level 4, for high Delta QP value"]
    pub const NV_ENC_EMPHASIS_MAP_LEVEL_4: Type = 4;
    #[doc = "< Emphasis Map Level 5, for very high Delta QP value"]
    pub const NV_ENC_EMPHASIS_MAP_LEVEL_5: Type = 5;
}
#[doc = " Emphasis Levels"]
pub use self::_NV_ENC_EMPHASIS_MAP_LEVEL::Type as NV_ENC_EMPHASIS_MAP_LEVEL;
pub mod _NV_ENC_QP_MAP_MODE {
    #[doc = " QP MAP MODE"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap have no effect."]
    pub const NV_ENC_QP_MAP_DISABLED: Type = 0;
    #[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as Emphasis level. Currently this is only supported for H264"]
    pub const NV_ENC_QP_MAP_EMPHASIS: Type = 1;
    #[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as QP delta map."]
    pub const NV_ENC_QP_MAP_DELTA: Type = 2;
    #[doc = "< Currently This is not supported. Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as QP value."]
    pub const NV_ENC_QP_MAP: Type = 3;
}
#[doc = " QP MAP MODE"]
pub use self::_NV_ENC_QP_MAP_MODE::Type as NV_ENC_QP_MAP_MODE;
pub mod _NV_ENC_PIC_STRUCT {
    #[doc = " Input picture structure"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Progressive frame"]
    pub const NV_ENC_PIC_STRUCT_FRAME: Type = 1;
    #[doc = "< Field encoding top field first"]
    pub const NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM: Type = 2;
    #[doc = "< Field encoding bottom field first"]
    pub const NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP: Type = 3;
}
#[doc = " Input picture structure"]
pub use self::_NV_ENC_PIC_STRUCT::Type as NV_ENC_PIC_STRUCT;
pub mod _NV_ENC_PIC_TYPE {
    #[doc = " Input picture type"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Forward predicted"]
    pub const NV_ENC_PIC_TYPE_P: Type = 0;
    #[doc = "< Bi-directionally predicted picture"]
    pub const NV_ENC_PIC_TYPE_B: Type = 1;
    #[doc = "< Intra predicted picture"]
    pub const NV_ENC_PIC_TYPE_I: Type = 2;
    #[doc = "< IDR picture"]
    pub const NV_ENC_PIC_TYPE_IDR: Type = 3;
    #[doc = "< Bi-directionally predicted with only Intra MBs"]
    pub const NV_ENC_PIC_TYPE_BI: Type = 4;
    #[doc = "< Picture is skipped"]
    pub const NV_ENC_PIC_TYPE_SKIPPED: Type = 5;
    #[doc = "< First picture in intra refresh cycle"]
    pub const NV_ENC_PIC_TYPE_INTRA_REFRESH: Type = 6;
    #[doc = "< Non reference P picture"]
    pub const NV_ENC_PIC_TYPE_NONREF_P: Type = 7;
    #[doc = "< Picture type unknown"]
    pub const NV_ENC_PIC_TYPE_UNKNOWN: Type = 255;
}
#[doc = " Input picture type"]
pub use self::_NV_ENC_PIC_TYPE::Type as NV_ENC_PIC_TYPE;
pub mod _NV_ENC_MV_PRECISION {
    #[doc = " Motion vector precisions"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Driver selects Quarter-Pel motion vector precision by default"]
    pub const NV_ENC_MV_PRECISION_DEFAULT: Type = 0;
    #[doc = "< Full-Pel motion vector precision"]
    pub const NV_ENC_MV_PRECISION_FULL_PEL: Type = 1;
    #[doc = "< Half-Pel motion vector precision"]
    pub const NV_ENC_MV_PRECISION_HALF_PEL: Type = 2;
    #[doc = "< Quarter-Pel motion vector precision"]
    pub const NV_ENC_MV_PRECISION_QUARTER_PEL: Type = 3;
}
#[doc = " Motion vector precisions"]
pub use self::_NV_ENC_MV_PRECISION::Type as NV_ENC_MV_PRECISION;
pub mod _NV_ENC_BUFFER_FORMAT {
    #[doc = " Input buffer formats"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Undefined buffer format"]
    pub const NV_ENC_BUFFER_FORMAT_UNDEFINED: Type = 0;
    #[doc = "< Semi-Planar YUV [Y plane followed by interleaved UV plane]"]
    pub const NV_ENC_BUFFER_FORMAT_NV12: Type = 1;
    #[doc = "< Planar YUV [Y plane followed by V and U planes]"]
    pub const NV_ENC_BUFFER_FORMAT_YV12: Type = 16;
    #[doc = "< Planar YUV [Y plane followed by U and V planes]"]
    pub const NV_ENC_BUFFER_FORMAT_IYUV: Type = 256;
    #[doc = "< Planar YUV [Y plane followed by U and V planes]"]
    pub const NV_ENC_BUFFER_FORMAT_YUV444: Type = 4096;
    #[doc = "< 10 bit Semi-Planar YUV [Y plane followed by interleaved UV plane]. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data."]
    pub const NV_ENC_BUFFER_FORMAT_YUV420_10BIT: Type = 65536;
    #[doc = "< 10 bit Planar YUV444 [Y plane followed by U and V planes]. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data."]
    pub const NV_ENC_BUFFER_FORMAT_YUV444_10BIT: Type = 1048576;
    #[doc = "< 8 bit Packed A8R8G8B8. This is a word-ordered format"]
    #[doc = "where a pixel is represented by a 32-bit word with B"]
    #[doc = "in the lowest 8 bits, G in the next 8 bits, R in the"]
    #[doc = "8 bits after that and A in the highest 8 bits."]
    pub const NV_ENC_BUFFER_FORMAT_ARGB: Type = 16777216;
    #[doc = "< 10 bit Packed A2R10G10B10. This is a word-ordered format"]
    #[doc = "where a pixel is represented by a 32-bit word with B"]
    #[doc = "in the lowest 10 bits, G in the next 10 bits, R in the"]
    #[doc = "10 bits after that and A in the highest 2 bits."]
    pub const NV_ENC_BUFFER_FORMAT_ARGB10: Type = 33554432;
    #[doc = "< 8 bit Packed A8Y8U8V8. This is a word-ordered format"]
    #[doc = "where a pixel is represented by a 32-bit word with V"]
    #[doc = "in the lowest 8 bits, U in the next 8 bits, Y in the"]
    #[doc = "8 bits after that and A in the highest 8 bits."]
    pub const NV_ENC_BUFFER_FORMAT_AYUV: Type = 67108864;
    #[doc = "< 8 bit Packed A8B8G8R8. This is a word-ordered format"]
    #[doc = "where a pixel is represented by a 32-bit word with R"]
    #[doc = "in the lowest 8 bits, G in the next 8 bits, B in the"]
    #[doc = "8 bits after that and A in the highest 8 bits."]
    pub const NV_ENC_BUFFER_FORMAT_ABGR: Type = 268435456;
    #[doc = "< 10 bit Packed A2B10G10R10. This is a word-ordered format"]
    #[doc = "where a pixel is represented by a 32-bit word with R"]
    #[doc = "in the lowest 10 bits, G in the next 10 bits, B in the"]
    #[doc = "10 bits after that and A in the highest 2 bits."]
    pub const NV_ENC_BUFFER_FORMAT_ABGR10: Type = 536870912;
    #[doc = "< Buffer format representing one-dimensional buffer."]
    #[doc = "This format should be used only when registering the"]
    #[doc = "resource as output buffer, which will be used to write"]
    #[doc = "the encoded bit stream or H.264 ME only mode output."]
    pub const NV_ENC_BUFFER_FORMAT_U8: Type = 1073741824;
}
#[doc = " Input buffer formats"]
pub use self::_NV_ENC_BUFFER_FORMAT::Type as NV_ENC_BUFFER_FORMAT;
pub mod _NV_ENC_LEVEL {
    #[doc = " Encoding levels"]
    pub type Type = ::std::os::raw::c_int;
    pub const NV_ENC_LEVEL_AUTOSELECT: Type = 0;
    pub const NV_ENC_LEVEL_H264_1: Type = 10;
    pub const NV_ENC_LEVEL_H264_1b: Type = 9;
    pub const NV_ENC_LEVEL_H264_11: Type = 11;
    pub const NV_ENC_LEVEL_H264_12: Type = 12;
    pub const NV_ENC_LEVEL_H264_13: Type = 13;
    pub const NV_ENC_LEVEL_H264_2: Type = 20;
    pub const NV_ENC_LEVEL_H264_21: Type = 21;
    pub const NV_ENC_LEVEL_H264_22: Type = 22;
    pub const NV_ENC_LEVEL_H264_3: Type = 30;
    pub const NV_ENC_LEVEL_H264_31: Type = 31;
    pub const NV_ENC_LEVEL_H264_32: Type = 32;
    pub const NV_ENC_LEVEL_H264_4: Type = 40;
    pub const NV_ENC_LEVEL_H264_41: Type = 41;
    pub const NV_ENC_LEVEL_H264_42: Type = 42;
    pub const NV_ENC_LEVEL_H264_5: Type = 50;
    pub const NV_ENC_LEVEL_H264_51: Type = 51;
    pub const NV_ENC_LEVEL_H264_52: Type = 52;
    pub const NV_ENC_LEVEL_H264_60: Type = 60;
    pub const NV_ENC_LEVEL_H264_61: Type = 61;
    pub const NV_ENC_LEVEL_H264_62: Type = 62;
    pub const NV_ENC_LEVEL_HEVC_1: Type = 30;
    pub const NV_ENC_LEVEL_HEVC_2: Type = 60;
    pub const NV_ENC_LEVEL_HEVC_21: Type = 63;
    pub const NV_ENC_LEVEL_HEVC_3: Type = 90;
    pub const NV_ENC_LEVEL_HEVC_31: Type = 93;
    pub const NV_ENC_LEVEL_HEVC_4: Type = 120;
    pub const NV_ENC_LEVEL_HEVC_41: Type = 123;
    pub const NV_ENC_LEVEL_HEVC_5: Type = 150;
    pub const NV_ENC_LEVEL_HEVC_51: Type = 153;
    pub const NV_ENC_LEVEL_HEVC_52: Type = 156;
    pub const NV_ENC_LEVEL_HEVC_6: Type = 180;
    pub const NV_ENC_LEVEL_HEVC_61: Type = 183;
    pub const NV_ENC_LEVEL_HEVC_62: Type = 186;
    pub const NV_ENC_TIER_HEVC_MAIN: Type = 0;
    pub const NV_ENC_TIER_HEVC_HIGH: Type = 1;
}
#[doc = " Encoding levels"]
pub use self::_NV_ENC_LEVEL::Type as NV_ENC_LEVEL;
pub mod _NVENCSTATUS {
    #[doc = " Error Codes"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = " This indicates that API call returned with no errors."]
    pub const NV_ENC_SUCCESS: Type = 0;
    #[doc = " This indicates that no encode capable devices were detected."]
    pub const NV_ENC_ERR_NO_ENCODE_DEVICE: Type = 1;
    #[doc = " This indicates that devices pass by the client is not supported."]
    pub const NV_ENC_ERR_UNSUPPORTED_DEVICE: Type = 2;
    #[doc = " This indicates that the encoder device supplied by the client is not"]
    #[doc = " valid."]
    pub const NV_ENC_ERR_INVALID_ENCODERDEVICE: Type = 3;
    #[doc = " This indicates that device passed to the API call is invalid."]
    pub const NV_ENC_ERR_INVALID_DEVICE: Type = 4;
    #[doc = " This indicates that device passed to the API call is no longer available and"]
    #[doc = " needs to be reinitialized. The clients need to destroy the current encoder"]
    #[doc = " session by freeing the allocated input output buffers and destroying the device"]
    #[doc = " and create a new encoding session."]
    pub const NV_ENC_ERR_DEVICE_NOT_EXIST: Type = 5;
    #[doc = " This indicates that one or more of the pointers passed to the API call"]
    #[doc = " is invalid."]
    pub const NV_ENC_ERR_INVALID_PTR: Type = 6;
    #[doc = " This indicates that completion event passed in ::NvEncEncodePicture() call"]
    #[doc = " is invalid."]
    pub const NV_ENC_ERR_INVALID_EVENT: Type = 7;
    #[doc = " This indicates that one or more of the parameter passed to the API call"]
    #[doc = " is invalid."]
    pub const NV_ENC_ERR_INVALID_PARAM: Type = 8;
    #[doc = " This indicates that an API call was made in wrong sequence/order."]
    pub const NV_ENC_ERR_INVALID_CALL: Type = 9;
    #[doc = " This indicates that the API call failed because it was unable to allocate"]
    #[doc = " enough memory to perform the requested operation."]
    pub const NV_ENC_ERR_OUT_OF_MEMORY: Type = 10;
    #[doc = " This indicates that the encoder has not been initialized with"]
    #[doc = " ::NvEncInitializeEncoder() or that initialization has failed."]
    #[doc = " The client cannot allocate input or output buffers or do any encoding"]
    #[doc = " related operation before successfully initializing the encoder."]
    pub const NV_ENC_ERR_ENCODER_NOT_INITIALIZED: Type = 11;
    #[doc = " This indicates that an unsupported parameter was passed by the client."]
    pub const NV_ENC_ERR_UNSUPPORTED_PARAM: Type = 12;
    #[doc = " This indicates that the ::NvEncLockBitstream() failed to lock the output"]
    #[doc = " buffer. This happens when the client makes a non blocking lock call to"]
    #[doc = " access the output bitstream by passing NV_ENC_LOCK_BITSTREAM::doNotWait flag."]
    #[doc = " This is not a fatal error and client should retry the same operation after"]
    #[doc = " few milliseconds."]
    pub const NV_ENC_ERR_LOCK_BUSY: Type = 13;
    #[doc = " This indicates that the size of the user buffer passed by the client is"]
    #[doc = " insufficient for the requested operation."]
    pub const NV_ENC_ERR_NOT_ENOUGH_BUFFER: Type = 14;
    #[doc = " This indicates that an invalid struct version was used by the client."]
    pub const NV_ENC_ERR_INVALID_VERSION: Type = 15;
    #[doc = " This indicates that ::NvEncMapInputResource() API failed to map the client"]
    #[doc = " provided input resource."]
    pub const NV_ENC_ERR_MAP_FAILED: Type = 16;
    #[doc = " This indicates encode driver requires more input buffers to produce an output"]
    #[doc = " bitstream. If this error is returned from ::NvEncEncodePicture() API, this"]
    #[doc = " is not a fatal error. If the client is encoding with B frames then,"]
    #[doc = " ::NvEncEncodePicture() API might be buffering the input frame for re-ordering."]
    #[doc = ""]
    #[doc = " A client operating in synchronous mode cannot call ::NvEncLockBitstream()"]
    #[doc = " API on the output bitstream buffer if ::NvEncEncodePicture() returned the"]
    #[doc = " ::NV_ENC_ERR_NEED_MORE_INPUT error code."]
    #[doc = " The client must continue providing input frames until encode driver returns"]
    #[doc = " ::NV_ENC_SUCCESS. After receiving ::NV_ENC_SUCCESS status the client can call"]
    #[doc = " ::NvEncLockBitstream() API on the output buffers in the same order in which"]
    #[doc = " it has called ::NvEncEncodePicture()."]
    pub const NV_ENC_ERR_NEED_MORE_INPUT: Type = 17;
    #[doc = " This indicates that the HW encoder is busy encoding and is unable to encode"]
    #[doc = " the input. The client should call ::NvEncEncodePicture() again after few"]
    #[doc = " milliseconds."]
    pub const NV_ENC_ERR_ENCODER_BUSY: Type = 18;
    #[doc = " This indicates that the completion event passed in ::NvEncEncodePicture()"]
    #[doc = " API has not been registered with encoder driver using ::NvEncRegisterAsyncEvent()."]
    pub const NV_ENC_ERR_EVENT_NOT_REGISTERD: Type = 19;
    #[doc = " This indicates that an unknown internal error has occurred."]
    pub const NV_ENC_ERR_GENERIC: Type = 20;
    #[doc = " This indicates that the client is attempting to use a feature"]
    #[doc = " that is not available for the license type for the current system."]
    pub const NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY: Type = 21;
    #[doc = " This indicates that the client is attempting to use a feature"]
    #[doc = " that is not implemented for the current version."]
    pub const NV_ENC_ERR_UNIMPLEMENTED: Type = 22;
    #[doc = " This indicates that the ::NvEncRegisterResource API failed to register the resource."]
    pub const NV_ENC_ERR_RESOURCE_REGISTER_FAILED: Type = 23;
    #[doc = " This indicates that the client is attempting to unregister a resource"]
    #[doc = " that has not been successfully registered."]
    pub const NV_ENC_ERR_RESOURCE_NOT_REGISTERED: Type = 24;
    #[doc = " This indicates that the client is attempting to unmap a resource"]
    #[doc = " that has not been successfully mapped."]
    pub const NV_ENC_ERR_RESOURCE_NOT_MAPPED: Type = 25;
}
#[doc = " Error Codes"]
pub use self::_NVENCSTATUS::Type as NVENCSTATUS;
pub mod _NV_ENC_PIC_FLAGS {
    #[doc = " Encode Picture encode flags."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Encode the current picture as an Intra picture"]
    pub const NV_ENC_PIC_FLAG_FORCEINTRA: Type = 1;
    #[doc = "< Encode the current picture as an IDR picture."]
    #[doc = "This flag is only valid when Picture type decision is taken by the Encoder"]
    #[doc = "[_NV_ENC_INITIALIZE_PARAMS::enablePTD == 1]."]
    pub const NV_ENC_PIC_FLAG_FORCEIDR: Type = 2;
    #[doc = "< Write the sequence and picture header in encoded bitstream of the current picture"]
    pub const NV_ENC_PIC_FLAG_OUTPUT_SPSPPS: Type = 4;
    #[doc = "< Indicates end of the input stream"]
    pub const NV_ENC_PIC_FLAG_EOS: Type = 8;
}
#[doc = " Encode Picture encode flags."]
pub use self::_NV_ENC_PIC_FLAGS::Type as NV_ENC_PIC_FLAGS;
pub mod _NV_ENC_MEMORY_HEAP {
    #[doc = " Memory heap to allocate input and output buffers."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Memory heap to be decided by the encoder driver based on the usage"]
    pub const NV_ENC_MEMORY_HEAP_AUTOSELECT: Type = 0;
    #[doc = "< Memory heap is in local video memory"]
    pub const NV_ENC_MEMORY_HEAP_VID: Type = 1;
    #[doc = "< Memory heap is in cached system memory"]
    pub const NV_ENC_MEMORY_HEAP_SYSMEM_CACHED: Type = 2;
    #[doc = "< Memory heap is in uncached system memory"]
    pub const NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED: Type = 3;
}
#[doc = " Memory heap to allocate input and output buffers."]
pub use self::_NV_ENC_MEMORY_HEAP::Type as NV_ENC_MEMORY_HEAP;
pub mod _NV_ENC_BFRAME_REF_MODE {
    #[doc = " B-frame used as reference modes"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< B frame is not used for reference"]
    pub const NV_ENC_BFRAME_REF_MODE_DISABLED: Type = 0;
    #[doc = "< Each B-frame will be used for reference. currently not supported for H.264"]
    pub const NV_ENC_BFRAME_REF_MODE_EACH: Type = 1;
    #[doc = "< Only(Number of B-frame)/2 th B-frame will be used for reference"]
    pub const NV_ENC_BFRAME_REF_MODE_MIDDLE: Type = 2;
}
#[doc = " B-frame used as reference modes"]
pub use self::_NV_ENC_BFRAME_REF_MODE::Type as NV_ENC_BFRAME_REF_MODE;
pub mod _NV_ENC_H264_ENTROPY_CODING_MODE {
    #[doc = " H.264 entropy coding modes."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Entropy coding mode is auto selected by the encoder driver"]
    pub const NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT: Type = 0;
    #[doc = "< Entropy coding mode is CABAC"]
    pub const NV_ENC_H264_ENTROPY_CODING_MODE_CABAC: Type = 1;
    #[doc = "< Entropy coding mode is CAVLC"]
    pub const NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC: Type = 2;
}
#[doc = " H.264 entropy coding modes."]
pub use self::_NV_ENC_H264_ENTROPY_CODING_MODE::Type as NV_ENC_H264_ENTROPY_CODING_MODE;
pub mod _NV_ENC_H264_BDIRECT_MODE {
    #[doc = " H.264 specific BDirect modes"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< BDirect mode is auto selected by the encoder driver"]
    pub const NV_ENC_H264_BDIRECT_MODE_AUTOSELECT: Type = 0;
    #[doc = "< Disable BDirect mode"]
    pub const NV_ENC_H264_BDIRECT_MODE_DISABLE: Type = 1;
    #[doc = "< Temporal BDirect mode"]
    pub const NV_ENC_H264_BDIRECT_MODE_TEMPORAL: Type = 2;
    #[doc = "< Spatial BDirect mode"]
    pub const NV_ENC_H264_BDIRECT_MODE_SPATIAL: Type = 3;
}
#[doc = " H.264 specific BDirect modes"]
pub use self::_NV_ENC_H264_BDIRECT_MODE::Type as NV_ENC_H264_BDIRECT_MODE;
pub mod _NV_ENC_H264_FMO_MODE {
    #[doc = " H.264 specific FMO usage"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< FMO usage is auto selected by the encoder driver"]
    pub const NV_ENC_H264_FMO_AUTOSELECT: Type = 0;
    #[doc = "< Enable FMO"]
    pub const NV_ENC_H264_FMO_ENABLE: Type = 1;
    #[doc = "< Disable FMO"]
    pub const NV_ENC_H264_FMO_DISABLE: Type = 2;
}
#[doc = " H.264 specific FMO usage"]
pub use self::_NV_ENC_H264_FMO_MODE::Type as NV_ENC_H264_FMO_MODE;
pub mod _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE {
    #[doc = " H.264 specific Adaptive Transform modes"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Adaptive Transform 8x8 mode is auto selected by the encoder driver"]
    pub const NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT: Type = 0;
    #[doc = "< Adaptive Transform 8x8 mode disabled"]
    pub const NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE: Type = 1;
    #[doc = "< Adaptive Transform 8x8 mode should be used"]
    pub const NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE: Type = 2;
}
#[doc = " H.264 specific Adaptive Transform modes"]
pub use self::_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE::Type as NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE;
pub mod _NV_ENC_STEREO_PACKING_MODE {
    #[doc = " Stereo frame packing modes."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< No Stereo packing required"]
    pub const NV_ENC_STEREO_PACKING_MODE_NONE: Type = 0;
    #[doc = "< Checkerboard mode for packing stereo frames"]
    pub const NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD: Type = 1;
    #[doc = "< Column Interleave mode for packing stereo frames"]
    pub const NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE: Type = 2;
    #[doc = "< Row Interleave mode for packing stereo frames"]
    pub const NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE: Type = 3;
    #[doc = "< Side-by-side mode for packing stereo frames"]
    pub const NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE: Type = 4;
    #[doc = "< Top-Bottom mode for packing stereo frames"]
    pub const NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM: Type = 5;
    #[doc = "< Frame Sequential mode for packing stereo frames"]
    pub const NV_ENC_STEREO_PACKING_MODE_FRAMESEQ: Type = 6;
}
#[doc = " Stereo frame packing modes."]
pub use self::_NV_ENC_STEREO_PACKING_MODE::Type as NV_ENC_STEREO_PACKING_MODE;
pub mod _NV_ENC_INPUT_RESOURCE_TYPE {
    #[doc = "  Input Resource type"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< input resource type is a directx9 surface"]
    pub const NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX: Type = 0;
    #[doc = "< input resource type is a cuda device pointer surface"]
    pub const NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR: Type = 1;
    #[doc = "< input resource type is a cuda array surface."]
    #[doc = "This array must be a 2D array and the CUDA_ARRAY3D_SURFACE_LDST"]
    #[doc = "flag must have been specified when creating it."]
    pub const NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY: Type = 2;
    #[doc = "< input resource type is an OpenGL texture"]
    pub const NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX: Type = 3;
}
#[doc = "  Input Resource type"]
pub use self::_NV_ENC_INPUT_RESOURCE_TYPE::Type as NV_ENC_INPUT_RESOURCE_TYPE;
pub mod _NV_ENC_BUFFER_USAGE {
    #[doc = "  Buffer usage"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Registered surface will be used for input image"]
    pub const NV_ENC_INPUT_IMAGE: Type = 0;
    #[doc = "< Registered surface will be used for output of H.264 ME only mode."]
    #[doc = "This buffer usage type is not supported for HEVC ME only mode."]
    pub const NV_ENC_OUTPUT_MOTION_VECTOR: Type = 1;
    #[doc = "< Registered surface will be used for output bitstream in encoding"]
    pub const NV_ENC_OUTPUT_BITSTREAM: Type = 2;
}
#[doc = "  Buffer usage"]
pub use self::_NV_ENC_BUFFER_USAGE::Type as NV_ENC_BUFFER_USAGE;
pub mod _NV_ENC_DEVICE_TYPE {
    #[doc = "  Encoder Device type"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< encode device type is a directx9 device"]
    pub const NV_ENC_DEVICE_TYPE_DIRECTX: Type = 0;
    #[doc = "< encode device type is a cuda device"]
    pub const NV_ENC_DEVICE_TYPE_CUDA: Type = 1;
    #[doc = "< encode device type is an OpenGL device."]
    #[doc = "Use of this device type is supported only on Linux"]
    pub const NV_ENC_DEVICE_TYPE_OPENGL: Type = 2;
}
#[doc = "  Encoder Device type"]
pub use self::_NV_ENC_DEVICE_TYPE::Type as NV_ENC_DEVICE_TYPE;
pub mod _NV_ENC_NUM_REF_FRAMES {
    #[doc = " Number of reference frames"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Number of reference frames is auto selected by the encoder driver"]
    pub const NV_ENC_NUM_REF_FRAMES_AUTOSELECT: Type = 0;
    #[doc = "< Number of reference frames equal to 1"]
    pub const NV_ENC_NUM_REF_FRAMES_1: Type = 1;
    #[doc = "< Number of reference frames equal to 2"]
    pub const NV_ENC_NUM_REF_FRAMES_2: Type = 2;
    #[doc = "< Number of reference frames equal to 3"]
    pub const NV_ENC_NUM_REF_FRAMES_3: Type = 3;
    #[doc = "< Number of reference frames equal to 4"]
    pub const NV_ENC_NUM_REF_FRAMES_4: Type = 4;
    #[doc = "< Number of reference frames equal to 5"]
    pub const NV_ENC_NUM_REF_FRAMES_5: Type = 5;
    #[doc = "< Number of reference frames equal to 6"]
    pub const NV_ENC_NUM_REF_FRAMES_6: Type = 6;
    #[doc = "< Number of reference frames equal to 7"]
    pub const NV_ENC_NUM_REF_FRAMES_7: Type = 7;
}
#[doc = " Number of reference frames"]
pub use self::_NV_ENC_NUM_REF_FRAMES::Type as NV_ENC_NUM_REF_FRAMES;
pub mod _NV_ENC_CAPS {
    #[doc = " Encoder capabilities enumeration."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = " Maximum number of B-Frames supported."]
    pub const NV_ENC_CAPS_NUM_MAX_BFRAMES: Type = 0;
    #[doc = " Rate control modes supported."]
    #[doc = " \\n The API return value is a bitmask of the values in NV_ENC_PARAMS_RC_MODE."]
    pub const NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES: Type = 1;
    #[doc = " Indicates HW support for field mode encoding."]
    #[doc = " \\n 0 : Interlaced mode encoding is not supported."]
    #[doc = " \\n 1 : Interlaced field mode encoding is supported."]
    #[doc = " \\n 2 : Interlaced frame encoding and field mode encoding are both supported."]
    pub const NV_ENC_CAPS_SUPPORT_FIELD_ENCODING: Type = 2;
    #[doc = " Indicates HW support for monochrome mode encoding."]
    #[doc = " \\n 0 : Monochrome mode not supported."]
    #[doc = " \\n 1 : Monochrome mode supported."]
    pub const NV_ENC_CAPS_SUPPORT_MONOCHROME: Type = 3;
    #[doc = " Indicates HW support for FMO."]
    #[doc = " \\n 0 : FMO not supported."]
    #[doc = " \\n 1 : FMO supported."]
    pub const NV_ENC_CAPS_SUPPORT_FMO: Type = 4;
    #[doc = " Indicates HW capability for Quarter pel motion estimation."]
    #[doc = " \\n 0 : Quarter-Pel Motion Estimation not supported."]
    #[doc = " \\n 1 : Quarter-Pel Motion Estimation supported."]
    pub const NV_ENC_CAPS_SUPPORT_QPELMV: Type = 5;
    #[doc = " H.264 specific. Indicates HW support for BDirect modes."]
    #[doc = " \\n 0 : BDirect mode encoding not supported."]
    #[doc = " \\n 1 : BDirect mode encoding supported."]
    pub const NV_ENC_CAPS_SUPPORT_BDIRECT_MODE: Type = 6;
    #[doc = " H264 specific. Indicates HW support for CABAC entropy coding mode."]
    #[doc = " \\n 0 : CABAC entropy coding not supported."]
    #[doc = " \\n 1 : CABAC entropy coding supported."]
    pub const NV_ENC_CAPS_SUPPORT_CABAC: Type = 7;
    #[doc = " Indicates HW support for Adaptive Transform."]
    #[doc = " \\n 0 : Adaptive Transform not supported."]
    #[doc = " \\n 1 : Adaptive Transform supported."]
    pub const NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM: Type = 8;
    #[doc = " Indicates HW support for Multi View Coding."]
    #[doc = " \\n 0 : Multi View Coding not supported."]
    #[doc = " \\n 1 : Multi View Coding supported."]
    pub const NV_ENC_CAPS_SUPPORT_STEREO_MVC: Type = 9;
    #[doc = " Indicates HW support for encoding Temporal layers."]
    #[doc = " \\n 0 : Encoding Temporal layers not supported."]
    #[doc = " \\n 1 : Encoding Temporal layers supported."]
    pub const NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS: Type = 10;
    #[doc = " Indicates HW support for Hierarchical P frames."]
    #[doc = " \\n 0 : Hierarchical P frames not supported."]
    #[doc = " \\n 1 : Hierarchical P frames supported."]
    pub const NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES: Type = 11;
    #[doc = " Indicates HW support for Hierarchical B frames."]
    #[doc = " \\n 0 : Hierarchical B frames not supported."]
    #[doc = " \\n 1 : Hierarchical B frames supported."]
    pub const NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES: Type = 12;
    #[doc = " Maximum Encoding level supported (See ::NV_ENC_LEVEL for details)."]
    pub const NV_ENC_CAPS_LEVEL_MAX: Type = 13;
    #[doc = " Minimum Encoding level supported (See ::NV_ENC_LEVEL for details)."]
    pub const NV_ENC_CAPS_LEVEL_MIN: Type = 14;
    #[doc = " Indicates HW support for separate colour plane encoding."]
    #[doc = " \\n 0 : Separate colour plane encoding not supported."]
    #[doc = " \\n 1 : Separate colour plane encoding supported."]
    pub const NV_ENC_CAPS_SEPARATE_COLOUR_PLANE: Type = 15;
    #[doc = " Maximum output width supported."]
    pub const NV_ENC_CAPS_WIDTH_MAX: Type = 16;
    #[doc = " Maximum output height supported."]
    pub const NV_ENC_CAPS_HEIGHT_MAX: Type = 17;
    #[doc = " Indicates Temporal Scalability Support."]
    #[doc = " \\n 0 : Temporal SVC encoding not supported."]
    #[doc = " \\n 1 : Temporal SVC encoding supported."]
    pub const NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC: Type = 18;
    #[doc = " Indicates Dynamic Encode Resolution Change Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Dynamic Encode Resolution Change not supported."]
    #[doc = " \\n 1 : Dynamic Encode Resolution Change supported."]
    pub const NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE: Type = 19;
    #[doc = " Indicates Dynamic Encode Bitrate Change Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Dynamic Encode bitrate change not supported."]
    #[doc = " \\n 1 : Dynamic Encode bitrate change supported."]
    pub const NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE: Type = 20;
    #[doc = " Indicates Forcing Constant QP On The Fly Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Forcing constant QP on the fly not supported."]
    #[doc = " \\n 1 : Forcing constant QP on the fly supported."]
    pub const NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP: Type = 21;
    #[doc = " Indicates Dynamic rate control mode Change Support."]
    #[doc = " \\n 0 : Dynamic rate control mode change not supported."]
    #[doc = " \\n 1 : Dynamic rate control mode change supported."]
    pub const NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE: Type = 22;
    #[doc = " Indicates Subframe readback support for slice-based encoding. If this feature is supported, it can be enabled by setting enableSubFrameWrite = 1."]
    #[doc = " \\n 0 : Subframe readback not supported."]
    #[doc = " \\n 1 : Subframe readback supported."]
    pub const NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK: Type = 23;
    #[doc = " Indicates Constrained Encoding mode support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Constrained encoding mode not supported."]
    #[doc = " \\n 1 : Constrained encoding mode supported."]
    #[doc = " If this mode is supported client can enable this during initialization."]
    #[doc = " Client can then force a picture to be coded as constrained picture where"]
    #[doc = " in-loop filtering is disabled across slice boundaries and prediction vectors for inter"]
    #[doc = " macroblocks in each slice will be restricted to the slice region."]
    pub const NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING: Type = 24;
    #[doc = " Indicates Intra Refresh Mode Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Intra Refresh Mode not supported."]
    #[doc = " \\n 1 : Intra Refresh Mode supported."]
    pub const NV_ENC_CAPS_SUPPORT_INTRA_REFRESH: Type = 25;
    #[doc = " Indicates Custom VBV Buffer Size support. It can be used for capping frame size."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Custom VBV buffer size specification from client, not supported."]
    #[doc = " \\n 1 : Custom VBV buffer size specification from client, supported."]
    pub const NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE: Type = 26;
    #[doc = " Indicates Dynamic Slice Mode Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Dynamic Slice Mode not supported."]
    #[doc = " \\n 1 : Dynamic Slice Mode supported."]
    pub const NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE: Type = 27;
    #[doc = " Indicates Reference Picture Invalidation Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Reference Picture Invalidation not supported."]
    #[doc = " \\n 1 : Reference Picture Invalidation supported."]
    pub const NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION: Type = 28;
    #[doc = " Indicates support for Pre-Processing."]
    #[doc = " The API return value is a bitmask of the values defined in ::NV_ENC_PREPROC_FLAGS"]
    pub const NV_ENC_CAPS_PREPROC_SUPPORT: Type = 29;
    #[doc = " Indicates support Async mode."]
    #[doc = " \\n 0 : Async Encode mode not supported."]
    #[doc = " \\n 1 : Async Encode mode supported."]
    pub const NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT: Type = 30;
    #[doc = " Maximum MBs per frame supported."]
    pub const NV_ENC_CAPS_MB_NUM_MAX: Type = 31;
    #[doc = " Maximum aggregate throughput in MBs per sec."]
    pub const NV_ENC_CAPS_MB_PER_SEC_MAX: Type = 32;
    #[doc = " Indicates HW support for YUV444 mode encoding."]
    #[doc = " \\n 0 : YUV444 mode encoding not supported."]
    #[doc = " \\n 1 : YUV444 mode encoding supported."]
    pub const NV_ENC_CAPS_SUPPORT_YUV444_ENCODE: Type = 33;
    #[doc = " Indicates HW support for lossless encoding."]
    #[doc = " \\n 0 : lossless encoding not supported."]
    #[doc = " \\n 1 : lossless encoding supported."]
    pub const NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE: Type = 34;
    #[doc = " Indicates HW support for Sample Adaptive Offset."]
    #[doc = " \\n 0 : SAO not supported."]
    #[doc = " \\n 1 : SAO encoding supported."]
    pub const NV_ENC_CAPS_SUPPORT_SAO: Type = 35;
    #[doc = " Indicates HW support for Motion Estimation Only Mode."]
    #[doc = " \\n 0 : MEOnly Mode not supported."]
    #[doc = " \\n 1 : MEOnly Mode supported for I and P frames."]
    #[doc = " \\n 2 : MEOnly Mode supported for I, P and B frames."]
    pub const NV_ENC_CAPS_SUPPORT_MEONLY_MODE: Type = 36;
    #[doc = " Indicates HW support for lookahead encoding (enableLookahead=1)."]
    #[doc = " \\n 0 : Lookahead not supported."]
    #[doc = " \\n 1 : Lookahead supported."]
    pub const NV_ENC_CAPS_SUPPORT_LOOKAHEAD: Type = 37;
    #[doc = " Indicates HW support for temporal AQ encoding (enableTemporalAQ=1)."]
    #[doc = " \\n 0 : Temporal AQ not supported."]
    #[doc = " \\n 1 : Temporal AQ supported."]
    pub const NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ: Type = 38;
    #[doc = " Indicates HW support for 10 bit encoding."]
    #[doc = " \\n 0 : 10 bit encoding not supported."]
    #[doc = " \\n 1 : 10 bit encoding supported."]
    pub const NV_ENC_CAPS_SUPPORT_10BIT_ENCODE: Type = 39;
    #[doc = " Maximum number of Long Term Reference frames supported"]
    pub const NV_ENC_CAPS_NUM_MAX_LTR_FRAMES: Type = 40;
    #[doc = " Indicates HW support for Weighted Prediction."]
    #[doc = " \\n 0 : Weighted Prediction not supported."]
    #[doc = " \\n 1 : Weighted Prediction supported."]
    pub const NV_ENC_CAPS_SUPPORT_WEIGHTED_PREDICTION: Type = 41;
    #[doc = " On managed (vGPU) platforms (Windows only), this API, in conjunction with other GRID Management APIs, can be used"]
    #[doc = " to estimate the residual capacity of the hardware encoder on the GPU as a percentage of the total available encoder capacity."]
    #[doc = " This API can be called at any time; i.e. during the encode session or before opening the encode session."]
    #[doc = " If the available encoder capacity is returned as zero, applications may choose to switch to software encoding"]
    #[doc = " and continue to call this API (e.g. polling once per second) until capacity becomes available."]
    #[doc = ""]
    #[doc = " On bare metal (non-virtualized GPU) and linux platforms, this API always returns 100."]
    pub const NV_ENC_CAPS_DYNAMIC_QUERY_ENCODER_CAPACITY: Type = 42;
    #[doc = " Indicates B as reference support."]
    #[doc = " \\n 0 : B as reference is not supported."]
    #[doc = " \\n 1 : each B-Frame as reference is supported."]
    #[doc = " \\n 2 : only Middle B-frame as reference is supported."]
    pub const NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE: Type = 43;
    #[doc = " Indicates HW support for Emphasis Level Map based delta QP computation."]
    #[doc = " \\n 0 : Emphasis Level Map based delta QP not supported."]
    #[doc = " \\n 1 : Emphasis Level Map based delta QP is supported."]
    pub const NV_ENC_CAPS_SUPPORT_EMPHASIS_LEVEL_MAP: Type = 44;
    #[doc = " Minimum input width supported."]
    pub const NV_ENC_CAPS_WIDTH_MIN: Type = 45;
    #[doc = " Minimum input height supported."]
    pub const NV_ENC_CAPS_HEIGHT_MIN: Type = 46;
    #[doc = " Indicates HW support for multiple reference frames."]
    pub const NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES: Type = 47;
    #[doc = " Indicates HW support for HEVC with alpha encoding."]
    #[doc = " \\n 0 : HEVC with alpha encoding not supported."]
    #[doc = " \\n 1 : HEVC with alpha encoding is supported."]
    pub const NV_ENC_CAPS_SUPPORT_ALPHA_LAYER_ENCODING: Type = 48;
    #[doc = " Indicates number of Encoding engines present on GPU."]
    pub const NV_ENC_CAPS_NUM_ENCODER_ENGINES: Type = 49;
    #[doc = " Reserved - Not to be used by clients."]
    pub const NV_ENC_CAPS_EXPOSED_COUNT: Type = 50;
}
#[doc = " Encoder capabilities enumeration."]
pub use self::_NV_ENC_CAPS::Type as NV_ENC_CAPS;
pub mod _NV_ENC_HEVC_CUSIZE {
    #[doc = "  HEVC CU SIZE"]
    pub type Type = ::std::os::raw::c_int;
    pub const NV_ENC_HEVC_CUSIZE_AUTOSELECT: Type = 0;
    pub const NV_ENC_HEVC_CUSIZE_8x8: Type = 1;
    pub const NV_ENC_HEVC_CUSIZE_16x16: Type = 2;
    pub const NV_ENC_HEVC_CUSIZE_32x32: Type = 3;
    pub const NV_ENC_HEVC_CUSIZE_64x64: Type = 4;
}
#[doc = "  HEVC CU SIZE"]
pub use self::_NV_ENC_HEVC_CUSIZE::Type as NV_ENC_HEVC_CUSIZE;
#[doc = " Input struct for querying Encoding capabilities."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CAPS_PARAM {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CAPS_PARAM_VER"]
    pub version: u32,
    #[doc = "< [in]: Specifies the encode capability to be queried. Client should pass a member for ::NV_ENC_CAPS enum."]
    pub capsToQuery: NV_ENC_CAPS,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 62usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CAPS_PARAM() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CAPS_PARAM>(),
        256usize,
        concat!("Size of: ", stringify!(_NV_ENC_CAPS_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CAPS_PARAM>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CAPS_PARAM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CAPS_PARAM>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CAPS_PARAM>())).capsToQuery as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(capsToQuery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CAPS_PARAM>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Input struct for querying Encoding capabilities."]
pub type NV_ENC_CAPS_PARAM = _NV_ENC_CAPS_PARAM;
#[doc = " Encoder Output parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_ENCODE_OUT_PARAMS {
    #[doc = "< [out]: Struct version."]
    pub version: u32,
    #[doc = "< [out]: Encoded bitstream size in bytes"]
    pub bitstreamSizeInBytes: u32,
    #[doc = "< [out]: Reserved and must be set to 0"]
    pub reserved: [u32; 62usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_ENCODE_OUT_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_ENCODE_OUT_PARAMS>(),
        256usize,
        concat!("Size of: ", stringify!(_NV_ENC_ENCODE_OUT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_ENCODE_OUT_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_ENCODE_OUT_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_ENCODE_OUT_PARAMS>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_ENCODE_OUT_PARAMS>())).bitstreamSizeInBytes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(bitstreamSizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_ENCODE_OUT_PARAMS>())).reserved as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Encoder Output parameters"]
pub type NV_ENC_ENCODE_OUT_PARAMS = _NV_ENC_ENCODE_OUT_PARAMS;
#[doc = " Creation parameters for input buffer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CREATE_INPUT_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CREATE_INPUT_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [in]: Input frame width"]
    pub width: u32,
    #[doc = "< [in]: Input frame height"]
    pub height: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    #[doc = "< [in]: Input buffer format"]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Pointer to input buffer"]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Pointer to existing system memory buffer"]
    pub pSysMemBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 57usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_INPUT_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_INPUT_BUFFER>(),
        776usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_INPUT_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_INPUT_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_INPUT_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).width as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).height as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).memoryHeap as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).bufferFmt as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).reserved as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).inputBuffer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).pSysMemBuffer as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(pSysMemBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).reserved1 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).reserved2 as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Creation parameters for input buffer."]
pub type NV_ENC_CREATE_INPUT_BUFFER = _NV_ENC_CREATE_INPUT_BUFFER;
#[doc = " Creation parameters for output bitstream buffer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CREATE_BITSTREAM_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CREATE_BITSTREAM_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub size: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Pointer to the output bitstream buffer"]
    pub bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [out]: Reserved and should not be used"]
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and should be set to 0"]
    pub reserved1: [u32; 58usize],
    #[doc = "< [in]: Reserved and should be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_BITSTREAM_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>(),
        776usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).memoryHeap as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).reserved as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).bitstreamBuffer as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(bitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).bitstreamBufferPtr
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(bitstreamBufferPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).reserved1 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).reserved2 as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Creation parameters for output bitstream buffer."]
pub type NV_ENC_CREATE_BITSTREAM_BUFFER = _NV_ENC_CREATE_BITSTREAM_BUFFER;
#[doc = " Structs needed for ME only mode."]
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NV_ENC_MVECTOR {
    #[doc = "< the x component of MV in quarter-pel units"]
    pub mvx: i16,
    #[doc = "< the y component of MV in quarter-pel units"]
    pub mvy: i16,
}
#[test]
fn bindgen_test_layout__NV_ENC_MVECTOR() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_MVECTOR>(),
        4usize,
        concat!("Size of: ", stringify!(_NV_ENC_MVECTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_MVECTOR>(),
        2usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MVECTOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MVECTOR>())).mvx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MVECTOR),
            "::",
            stringify!(mvx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MVECTOR>())).mvy as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MVECTOR),
            "::",
            stringify!(mvy)
        )
    );
}
#[doc = " Structs needed for ME only mode."]
pub type NV_ENC_MVECTOR = _NV_ENC_MVECTOR;
#[doc = " Motion vector structure per macroblock for H264 motion estimation."]
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NV_ENC_H264_MV_DATA {
    #[doc = "< up to 4 vectors for 8x8 partition"]
    pub mv: [NV_ENC_MVECTOR; 4usize],
    #[doc = "< 0 (I), 1 (P), 2 (IPCM), 3 (B)"]
    pub mbType: u8,
    #[doc = "< Specifies the block partition type. 0:16x16, 1:8x8, 2:16x8, 3:8x16"]
    pub partitionType: u8,
    #[doc = "< reserved padding for alignment"]
    pub reserved: u16,
    pub mbCost: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_H264_MV_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_H264_MV_DATA>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_ENC_H264_MV_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_H264_MV_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_H264_MV_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_H264_MV_DATA>())).mv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_H264_MV_DATA>())).mbType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mbType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_H264_MV_DATA>())).partitionType as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(partitionType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_H264_MV_DATA>())).reserved as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_H264_MV_DATA>())).mbCost as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mbCost)
        )
    );
}
#[doc = " Motion vector structure per macroblock for H264 motion estimation."]
pub type NV_ENC_H264_MV_DATA = _NV_ENC_H264_MV_DATA;
#[doc = " Motion vector structure per CU for HEVC motion estimation."]
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NV_ENC_HEVC_MV_DATA {
    #[doc = "< up to 4 vectors within a CU"]
    pub mv: [NV_ENC_MVECTOR; 4usize],
    #[doc = "< 0 (I), 1(P)"]
    pub cuType: u8,
    #[doc = "< 0: 8x8, 1: 16x16, 2: 32x32, 3: 64x64"]
    pub cuSize: u8,
    #[doc = "< The CU partition mode"]
    #[doc = "0 (2Nx2N), 1 (2NxN), 2(Nx2N), 3 (NxN),"]
    #[doc = "4 (2NxnU), 5 (2NxnD), 6(nLx2N), 7 (nRx2N)"]
    pub partitionMode: u8,
    #[doc = "< Marker to separate CUs in the current CTB from CUs in the next CTB"]
    pub lastCUInCTB: u8,
}
#[test]
fn bindgen_test_layout__NV_ENC_HEVC_MV_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_HEVC_MV_DATA>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_ENC_HEVC_MV_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_HEVC_MV_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(_NV_ENC_HEVC_MV_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_HEVC_MV_DATA>())).mv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(mv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_HEVC_MV_DATA>())).cuType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(cuType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_HEVC_MV_DATA>())).cuSize as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(cuSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_HEVC_MV_DATA>())).partitionMode as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(partitionMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_HEVC_MV_DATA>())).lastCUInCTB as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(lastCUInCTB)
        )
    );
}
#[doc = " Motion vector structure per CU for HEVC motion estimation."]
pub type NV_ENC_HEVC_MV_DATA = _NV_ENC_HEVC_MV_DATA;
#[doc = " Creation parameters for output motion vector buffer for ME only mode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CREATE_MV_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to NV_ENC_CREATE_MV_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [out]: Pointer to the output motion vector buffer"]
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Reserved and should be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and should be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_MV_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_MV_BUFFER>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_MV_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_MV_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_MV_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).mvBuffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(mvBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).reserved1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).reserved2 as *const _ as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Creation parameters for output motion vector buffer for ME only mode."]
pub type NV_ENC_CREATE_MV_BUFFER = _NV_ENC_CREATE_MV_BUFFER;
#[doc = " QP value for frames"]
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NV_ENC_QP {
    #[doc = "< [in]: Specifies QP value for P-frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpInterP: u32,
    #[doc = "< [in]: Specifies QP value for B-frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpInterB: u32,
    #[doc = "< [in]: Specifies QP value for Intra Frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpIntra: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_QP() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_QP>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_ENC_QP))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_QP>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_QP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_QP>())).qpInterP as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpInterP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_QP>())).qpInterB as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpInterB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_QP>())).qpIntra as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpIntra)
        )
    );
}
#[doc = " QP value for frames"]
pub type NV_ENC_QP = _NV_ENC_QP;
#[doc = " Rate Control Configuration Parameters"]
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NV_ENC_RC_PARAMS {
    pub version: u32,
    #[doc = "< [in]: Specifies the rate control mode. Check support for various rate control modes using ::NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES caps."]
    pub rateControlMode: NV_ENC_PARAMS_RC_MODE,
    #[doc = "< [in]: Specifies the initial QP to be used for encoding, these values would be used for all frames if in Constant QP mode."]
    pub constQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the average bitrate(in bits/sec) used for encoding."]
    pub averageBitRate: u32,
    #[doc = "< [in]: Specifies the maximum bitrate for the encoded output. This is used for VBR and ignored for CBR mode."]
    pub maxBitRate: u32,
    #[doc = "< [in]: Specifies the VBV(HRD) buffer size. in bits. Set 0 to use the default VBV  buffer size."]
    pub vbvBufferSize: u32,
    #[doc = "< [in]: Specifies the VBV(HRD) initial delay in bits. Set 0 to use the default VBV  initial delay ."]
    pub vbvInitialDelay: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    #[doc = "< [in]: Specifies the minimum QP used for rate control. Client must set NV_ENC_CONFIG::enableMinQP to 1."]
    pub minQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the maximum QP used for rate control. Client must set NV_ENC_CONFIG::enableMaxQP to 1."]
    pub maxQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the initial QP used for rate control. Client must set NV_ENC_CONFIG::enableInitialRCQP to 1."]
    pub initialRCQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the temporal layers (as a bitmask) whose QPs have changed. Valid max bitmask is [2^NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS - 1]."]
    #[doc = "Applicable only for constant QP mode (NV_ENC_RC_PARAMS::rateControlMode = NV_ENC_PARAMS_RC_CONSTQP)."]
    pub temporallayerIdxMask: u32,
    #[doc = "< [in]: Specifies the temporal layer QPs used for rate control. Temporal layer index is used as the array index."]
    #[doc = "Applicable only for constant QP mode (NV_ENC_RC_PARAMS::rateControlMode = NV_ENC_PARAMS_RC_CONSTQP)."]
    pub temporalLayerQP: [u8; 8usize],
    #[doc = "< [in]: Target CQ (Constant Quality) level for VBR mode (range 0-51 with 0-automatic)"]
    pub targetQuality: u8,
    #[doc = "< [in]: Fractional part of target quality (as 8.8 fixed point format)"]
    pub targetQualityLSB: u8,
    #[doc = "< [in]: Maximum depth of lookahead with range 0-(31 - number of B frames)."]
    #[doc = "lookaheadDepth is only used if enableLookahead=1."]
    pub lookaheadDepth: u16,
    #[doc = "< [in]: Specifies the ratio of I frame bits to P frame bits in case of single frame VBV and CBR rate control mode,"]
    #[doc = "is set to 2 by default for low latency tuning info and 1 by default for ultra low latency tuning info"]
    pub lowDelayKeyFrameScale: u8,
    pub reserved1: [u8; 3usize],
    #[doc = "< [in]: This flag is used to interpret values in array specified by NV_ENC_PIC_PARAMS::qpDeltaMap."]
    #[doc = "Set this to NV_ENC_QP_MAP_EMPHASIS to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as Emphasis Level Map."]
    #[doc = "Emphasis Level can be assigned any value specified in enum NV_ENC_EMPHASIS_MAP_LEVEL."]
    #[doc = "Emphasis Level Map is used to specify regions to be encoded at varying levels of quality."]
    #[doc = "The hardware encoder adjusts the quantization within the image as per the provided emphasis map,"]
    #[doc = "by adjusting the quantization parameter (QP) assigned to each macroblock. This adjustment is commonly called Delta QP."]
    #[doc = "The adjustment depends on the absolute QP decided by the rate control algorithm, and is applied after the rate control has decided each macroblocks QP."]
    #[doc = "Since the Delta QP overrides rate control, enabling Emphasis Level Map may violate bitrate and VBV buffer size constraints."]
    #[doc = "Emphasis Level Map is useful in situations where client has a priori knowledge of the image complexity (e.g. via use of NVFBC's Classification feature) and encoding those high-complexity areas at higher quality (lower QP) is important, even at the possible cost of violating bitrate/VBV buffer size constraints"]
    #[doc = "This feature is not supported when AQ( Spatial/Temporal) is enabled."]
    #[doc = "This feature is only supported for H264 codec currently."]
    #[doc = ""]
    #[doc = "Set this to NV_ENC_QP_MAP_DELTA to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as QP Delta. This specifies QP modifier to be applied on top of the QP chosen by rate control"]
    #[doc = ""]
    #[doc = "Set this to NV_ENC_QP_MAP_DISABLED to ignore NV_ENC_PIC_PARAMS::qpDeltaMap values. In this case, qpDeltaMap should be set to NULL."]
    #[doc = ""]
    #[doc = "Other values are reserved for future use."]
    pub qpMapMode: NV_ENC_QP_MAP_MODE,
    #[doc = "< [in]: This flag is used to enable multi-pass encoding for a given ::NV_ENC_PARAMS_RC_MODE. This flag is not valid for H264 and HEVC MEOnly mode"]
    pub multiPass: NV_ENC_MULTI_PASS,
    #[doc = "< [in]: Specifies the ratio in which bitrate should be split between base and alpha layer. A value 'x' for this field will split the target bitrate in a ratio of x : 1 between base and alpha layer."]
    #[doc = "The default split ratio is 15."]
    pub alphaLayerBitrateRatio: u32,
    pub reserved: [u32; 5usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_RC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_RC_PARAMS>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_RC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_RC_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_RC_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).rateControlMode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(rateControlMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).constQP as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(constQP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).averageBitRate as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(averageBitRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).maxBitRate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(maxBitRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).vbvBufferSize as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vbvBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).vbvInitialDelay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vbvInitialDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).minQP as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(minQP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).maxQP as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(maxQP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).initialRCQP as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(initialRCQP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).temporallayerIdxMask as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(temporallayerIdxMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).temporalLayerQP as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(temporalLayerQP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).targetQuality as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(targetQuality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).targetQualityLSB as *const _ as usize
        },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(targetQualityLSB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).lookaheadDepth as *const _ as usize
        },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(lookaheadDepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).lowDelayKeyFrameScale as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(lowDelayKeyFrameScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).reserved1 as *const _ as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).qpMapMode as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(qpMapMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).multiPass as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(multiPass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).alphaLayerBitrateRatio as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(alphaLayerBitrateRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).reserved as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
impl _NV_ENC_RC_PARAMS {
    #[inline]
    pub fn enableMinQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMinQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableMaxQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMaxQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableInitialRCQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableInitialRCQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitField1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLookahead(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLookahead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableIadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableBadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableBadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableTemporalAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zeroReorderDelay(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zeroReorderDelay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableNonRefP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableNonRefP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strictGOPTarget(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strictGOPTarget(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aqStrength(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_aqStrength(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableMinQP: u32,
        enableMaxQP: u32,
        enableInitialRCQP: u32,
        enableAQ: u32,
        reservedBitField1: u32,
        enableLookahead: u32,
        disableIadapt: u32,
        disableBadapt: u32,
        enableTemporalAQ: u32,
        zeroReorderDelay: u32,
        enableNonRefP: u32,
        strictGOPTarget: u32,
        aqStrength: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableMinQP: u32 = unsafe { ::std::mem::transmute(enableMinQP) };
            enableMinQP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableMaxQP: u32 = unsafe { ::std::mem::transmute(enableMaxQP) };
            enableMaxQP as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableInitialRCQP: u32 = unsafe { ::std::mem::transmute(enableInitialRCQP) };
            enableInitialRCQP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableAQ: u32 = unsafe { ::std::mem::transmute(enableAQ) };
            enableAQ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reservedBitField1: u32 = unsafe { ::std::mem::transmute(reservedBitField1) };
            reservedBitField1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLookahead: u32 = unsafe { ::std::mem::transmute(enableLookahead) };
            enableLookahead as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableIadapt: u32 = unsafe { ::std::mem::transmute(disableIadapt) };
            disableIadapt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableBadapt: u32 = unsafe { ::std::mem::transmute(disableBadapt) };
            disableBadapt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableTemporalAQ: u32 = unsafe { ::std::mem::transmute(enableTemporalAQ) };
            enableTemporalAQ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let zeroReorderDelay: u32 = unsafe { ::std::mem::transmute(zeroReorderDelay) };
            zeroReorderDelay as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableNonRefP: u32 = unsafe { ::std::mem::transmute(enableNonRefP) };
            enableNonRefP as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let strictGOPTarget: u32 = unsafe { ::std::mem::transmute(strictGOPTarget) };
            strictGOPTarget as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let aqStrength: u32 = unsafe { ::std::mem::transmute(aqStrength) };
            aqStrength as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Rate Control Configuration Parameters"]
pub type NV_ENC_RC_PARAMS = _NV_ENC_RC_PARAMS;
#[doc = " \\struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS"]
#[doc = " H264 Video Usability Info parameters"]
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS {
    #[doc = "< [in]: if set to 1 , it specifies that the overscanInfo is present"]
    pub overscanInfoPresentFlag: u32,
    #[doc = "< [in]: Specifies the overscan info(as defined in Annex E of the ITU-T Specification)."]
    pub overscanInfo: u32,
    #[doc = "< [in]: If set to 1, it specifies  that the videoFormat, videoFullRangeFlag and colourDescriptionPresentFlag are present."]
    pub videoSignalTypePresentFlag: u32,
    #[doc = "< [in]: Specifies the source video format(as defined in Annex E of the ITU-T Specification)."]
    pub videoFormat: u32,
    #[doc = "< [in]: Specifies the output range of the luma and chroma samples(as defined in Annex E of the ITU-T Specification)."]
    pub videoFullRangeFlag: u32,
    #[doc = "< [in]: If set to 1, it specifies that the colourPrimaries, transferCharacteristics and colourMatrix are present."]
    pub colourDescriptionPresentFlag: u32,
    #[doc = "< [in]: Specifies color primaries for converting to RGB(as defined in Annex E of the ITU-T Specification)"]
    pub colourPrimaries: u32,
    #[doc = "< [in]: Specifies the opto-electronic transfer characteristics to use (as defined in Annex E of the ITU-T Specification)"]
    pub transferCharacteristics: u32,
    #[doc = "< [in]: Specifies the matrix coefficients used in deriving the luma and chroma from the RGB primaries (as defined in Annex E of the ITU-T Specification)."]
    pub colourMatrix: u32,
    #[doc = "< [in]: if set to 1 , it specifies that the chromaSampleLocationTop and chromaSampleLocationBot are present."]
    pub chromaSampleLocationFlag: u32,
    #[doc = "< [in]: Specifies the chroma sample location for top field(as defined in Annex E of the ITU-T Specification)"]
    pub chromaSampleLocationTop: u32,
    #[doc = "< [in]: Specifies the chroma sample location for bottom field(as defined in Annex E of the ITU-T Specification)"]
    pub chromaSampleLocationBot: u32,
    #[doc = "< [in]: if set to 1, it specifies the bitstream restriction parameters are present in the bitstream."]
    pub bitstreamRestrictionFlag: u32,
    pub reserved: [u32; 15usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264_VUI_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>(),
        112usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).overscanInfoPresentFlag
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(overscanInfoPresentFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).overscanInfo as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(overscanInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>()))
                .videoSignalTypePresentFlag as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoSignalTypePresentFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).videoFormat as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).videoFullRangeFlag
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoFullRangeFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>()))
                .colourDescriptionPresentFlag as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourDescriptionPresentFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).colourPrimaries
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourPrimaries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).transferCharacteristics
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(transferCharacteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).colourMatrix as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourMatrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).chromaSampleLocationFlag
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).chromaSampleLocationTop
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationTop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).chromaSampleLocationBot
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationBot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).bitstreamRestrictionFlag
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(bitstreamRestrictionFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).reserved as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " \\struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS"]
#[doc = " H264 Video Usability Info parameters"]
pub type NV_ENC_CONFIG_H264_VUI_PARAMETERS = _NV_ENC_CONFIG_H264_VUI_PARAMETERS;
pub type NV_ENC_CONFIG_HEVC_VUI_PARAMETERS = NV_ENC_CONFIG_H264_VUI_PARAMETERS;
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE"]
#[doc = " External motion vector hint counts per block type."]
#[doc = " H264 supports multiple hint while HEVC supports one hint for each valid candidate."]
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    #[doc = "< [in]: Reserved for future use."]
    pub reserved1: [u32; 3usize],
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE() {
    assert_eq!(
        ::std::mem::size_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>())).reserved1
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE),
            "::",
            stringify!(reserved1)
        )
    );
}
impl _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    #[inline]
    pub fn numCandsPerBlk16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        numCandsPerBlk16x16: u32,
        numCandsPerBlk16x8: u32,
        numCandsPerBlk8x16: u32,
        numCandsPerBlk8x8: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let numCandsPerBlk16x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x16) };
            numCandsPerBlk16x16 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let numCandsPerBlk16x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x8) };
            numCandsPerBlk16x8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numCandsPerBlk8x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x16) };
            numCandsPerBlk8x16 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCandsPerBlk8x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x8) };
            numCandsPerBlk8x8 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE"]
#[doc = " External motion vector hint counts per block type."]
#[doc = " H264 supports multiple hint while HEVC supports one hint for each valid candidate."]
pub type NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE = _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE;
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT"]
#[doc = " External Motion Vector hint structure."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_HINT() {
    assert_eq!(
        ::std::mem::size_of::<_NVENC_EXTERNAL_ME_HINT>(),
        4usize,
        concat!("Size of: ", stringify!(_NVENC_EXTERNAL_ME_HINT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVENC_EXTERNAL_ME_HINT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVENC_EXTERNAL_ME_HINT))
    );
}
impl _NVENC_EXTERNAL_ME_HINT {
    #[inline]
    pub fn mvx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn mvy(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn refidx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dir(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn partType(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_partType(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lastofPart(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastofPart(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lastOfMB(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastOfMB(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mvx: i32,
        mvy: i32,
        refidx: i32,
        dir: i32,
        partType: i32,
        lastofPart: i32,
        lastOfMB: i32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let mvx: u32 = unsafe { ::std::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(12usize, 10u8, {
            let mvy: u32 = unsafe { ::std::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let refidx: u32 = unsafe { ::std::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let dir: u32 = unsafe { ::std::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let partType: u32 = unsafe { ::std::mem::transmute(partType) };
            partType as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let lastofPart: u32 = unsafe { ::std::mem::transmute(lastofPart) };
            lastofPart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lastOfMB: u32 = unsafe { ::std::mem::transmute(lastOfMB) };
            lastOfMB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT"]
#[doc = " External Motion Vector hint structure."]
pub type NVENC_EXTERNAL_ME_HINT = _NVENC_EXTERNAL_ME_HINT;
#[doc = " \\struct _NV_ENC_CONFIG_H264"]
#[doc = " H264 encoder configuration parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG_H264 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    #[doc = "< [in]: Specifies the encoding level. Client is recommended to set this to NV_ENC_LEVEL_AUTOSELECT in order to enable the NvEncodeAPI interface to select the correct level."]
    pub level: u32,
    #[doc = "< [in]: Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG.Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically."]
    pub idrPeriod: u32,
    #[doc = "< [in]: Set to 1 to enable 4:4:4 separate colour planes"]
    pub separateColourPlaneFlag: u32,
    #[doc = "< [in]: Specifies the deblocking filter mode. Permissible value range: [0,2]. This flag corresponds"]
    #[doc = "to the flag disable_deblocking_filter_idc specified in section 7.4.3 of H.264 specification,"]
    #[doc = "which specifies whether the operation of the deblocking filter shall be disabled across some"]
    #[doc = "block edges of the slice and specifies for which edges the filtering is disabled. See section"]
    #[doc = "7.4.3 of H.264 specification for more details."]
    pub disableDeblockingFilterIDC: u32,
    #[doc = "< [in]: Specifies number of temporal layers to be used for hierarchical coding / temporal SVC. Valid value range is [1,::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS]"]
    pub numTemporalLayers: u32,
    #[doc = "< [in]: Specifies the SPS id of the sequence header"]
    pub spsId: u32,
    #[doc = "< [in]: Specifies the PPS id of the picture header"]
    pub ppsId: u32,
    #[doc = "< [in]: Specifies the AdaptiveTransform Mode. Check support for AdaptiveTransform mode using ::NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM caps."]
    pub adaptiveTransformMode: NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE,
    #[doc = "< [in]: Specified the FMO Mode. Check support for FMO using ::NV_ENC_CAPS_SUPPORT_FMO caps."]
    pub fmoMode: NV_ENC_H264_FMO_MODE,
    #[doc = "< [in]: Specifies the BDirect mode. Check support for BDirect mode using ::NV_ENC_CAPS_SUPPORT_BDIRECT_MODE caps."]
    pub bdirectMode: NV_ENC_H264_BDIRECT_MODE,
    #[doc = "< [in]: Specifies the entropy coding mode. Check support for CABAC mode using ::NV_ENC_CAPS_SUPPORT_CABAC caps."]
    pub entropyCodingMode: NV_ENC_H264_ENTROPY_CODING_MODE,
    #[doc = "< [in]: Specifies the stereo frame packing mode which is to be signaled in frame packing arrangement SEI"]
    pub stereoMode: NV_ENC_STEREO_PACKING_MODE,
    #[doc = "< [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set."]
    #[doc = "Will be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH."]
    pub intraRefreshPeriod: u32,
    #[doc = "< [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod"]
    pub intraRefreshCnt: u32,
    #[doc = "< [in]: Specifies the DPB size used for encoding. Setting it to 0 will let driver use the default DPB size."]
    #[doc = "The low latency application which wants to invalidate reference frame as an error resilience tool"]
    #[doc = "is recommended to use a large DPB size so that the encoder can keep old reference frames which can be used if recent"]
    #[doc = "frames are invalidated."]
    pub maxNumRefFrames: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 MB based slices, sliceMode = 1 Byte based slices, sliceMode = 2 MB row based slices, sliceMode = 3 numSlices in Picture."]
    #[doc = "When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of MBs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of MB rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the H264 video usability info parameters"]
    pub h264VUIParameters: NV_ENC_CONFIG_H264_VUI_PARAMETERS,
    #[doc = "< [in]: Specifies the number of LTR frames. This parameter has different meaning in two LTR modes."]
    #[doc = "In \"LTR Trust\" mode (ltrTrustMode = 1), encoder will mark the first ltrNumFrames base layer reference frames within each IDR interval as LTR."]
    #[doc = "In \"LTR Per Picture\" mode (ltrTrustMode = 0 and ltrMarkFrame = 1), ltrNumFrames specifies maximum number of LTR frames in DPB."]
    pub ltrNumFrames: u32,
    #[doc = "< [in]: Specifies the LTR operating mode. See comments near NV_ENC_CONFIG_H264::enableLTR for description of the two modes."]
    #[doc = "Set to 1 to use \"LTR Trust\" mode of LTR operation. Clients are discouraged to use \"LTR Trust\" mode as this mode may"]
    #[doc = "be deprecated in future releases."]
    #[doc = "Set to 0 when using \"LTR Per Picture\" mode of LTR operation."]
    pub ltrTrustMode: u32,
    #[doc = "< [in]: Specifies the chroma format. Should be set to 1 for yuv420 input, 3 for yuv444 input."]
    #[doc = "Check support for YUV444 encoding using ::NV_ENC_CAPS_SUPPORT_YUV444_ENCODE caps."]
    pub chromaFormatIDC: u32,
    #[doc = "< [in]: Specifies the maximum temporal layer used for temporal SVC / hierarchical coding."]
    #[doc = "Defaut value of this field is NV_ENC_CAPS::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS. Note that the value NV_ENC_CONFIG_H264::maxNumRefFrames should"]
    #[doc = "be greater than or equal to (NV_ENC_CONFIG_H264::maxTemporalLayers - 2) * 2, for NV_ENC_CONFIG_H264::maxTemporalLayers >= 2."]
    pub maxTemporalLayers: u32,
    #[doc = "< [in]: Specifies the B-Frame as reference mode. Check support for useBFramesAsRef mode using ::NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE caps."]
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL0 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL1 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 267usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264>(),
        1792usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_H264))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).idrPeriod as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).separateColourPlaneFlag as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(separateColourPlaneFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).disableDeblockingFilterIDC as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(disableDeblockingFilterIDC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).numTemporalLayers as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numTemporalLayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).spsId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).ppsId as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).adaptiveTransformMode as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(adaptiveTransformMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).fmoMode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(fmoMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).bdirectMode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(bdirectMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).entropyCodingMode as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(entropyCodingMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).stereoMode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(stereoMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).intraRefreshPeriod as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).intraRefreshCnt as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).maxNumRefFrames as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(maxNumRefFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).sliceMode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).sliceModeData as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).h264VUIParameters as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(h264VUIParameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).ltrNumFrames as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ltrNumFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).ltrTrustMode as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ltrTrustMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).chromaFormatIDC as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(chromaFormatIDC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).maxTemporalLayers as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(maxTemporalLayers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).useBFramesAsRef as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).numRefL0 as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numRefL0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).numRefL1 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numRefL1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).reserved1 as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).reserved2 as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_CONFIG_H264 {
    #[inline]
    pub fn enableTemporalSVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalSVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableStereoMVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableStereoMVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hierarchicalPFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalPFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hierarchicalBFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalBFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputFramePackingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputFramePackingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableVFR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableVFR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qpPrimeYZeroTransformBypassFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_qpPrimeYZeroTransformBypassFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSVCPrefixNalu(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSVCPrefixNalu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableScalabilityInfoSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableScalabilityInfoSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableTemporalSVC: u32,
        enableStereoMVC: u32,
        hierarchicalPFrames: u32,
        hierarchicalBFrames: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        disableSPSPPS: u32,
        outputFramePackingSEI: u32,
        outputRecoveryPointSEI: u32,
        enableIntraRefresh: u32,
        enableConstrainedEncoding: u32,
        repeatSPSPPS: u32,
        enableVFR: u32,
        enableLTR: u32,
        qpPrimeYZeroTransformBypassFlag: u32,
        useConstrainedIntraPred: u32,
        enableFillerDataInsertion: u32,
        disableSVCPrefixNalu: u32,
        enableScalabilityInfoSEI: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableTemporalSVC: u32 = unsafe { ::std::mem::transmute(enableTemporalSVC) };
            enableTemporalSVC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableStereoMVC: u32 = unsafe { ::std::mem::transmute(enableStereoMVC) };
            enableStereoMVC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hierarchicalPFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalPFrames) };
            hierarchicalPFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hierarchicalBFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalBFrames) };
            hierarchicalBFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let outputFramePackingSEI: u32 =
                unsafe { ::std::mem::transmute(outputFramePackingSEI) };
            outputFramePackingSEI as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::std::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::std::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enableVFR: u32 = unsafe { ::std::mem::transmute(enableVFR) };
            enableVFR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let qpPrimeYZeroTransformBypassFlag: u32 =
                unsafe { ::std::mem::transmute(qpPrimeYZeroTransformBypassFlag) };
            qpPrimeYZeroTransformBypassFlag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::std::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let disableSVCPrefixNalu: u32 = unsafe { ::std::mem::transmute(disableSVCPrefixNalu) };
            disableSVCPrefixNalu as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let enableScalabilityInfoSEI: u32 =
                unsafe { ::std::mem::transmute(enableScalabilityInfoSEI) };
            enableScalabilityInfoSEI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_H264"]
#[doc = " H264 encoder configuration parameters"]
pub type NV_ENC_CONFIG_H264 = _NV_ENC_CONFIG_H264;
#[doc = " \\struct _NV_ENC_CONFIG_HEVC"]
#[doc = " HEVC encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG_HEVC {
    #[doc = "< [in]: Specifies the level of the encoded bitstream."]
    pub level: u32,
    #[doc = "< [in]: Specifies the level tier of the encoded bitstream."]
    pub tier: u32,
    #[doc = "< [in]: Specifies the minimum size of luma coding unit."]
    pub minCUSize: NV_ENC_HEVC_CUSIZE,
    #[doc = "< [in]: Specifies the maximum size of luma coding unit. Currently NVENC SDK only supports maxCUSize equal to NV_ENC_HEVC_CUSIZE_32x32."]
    pub maxCUSize: NV_ENC_HEVC_CUSIZE,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    #[doc = "< [in]: Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG. Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically."]
    pub idrPeriod: u32,
    #[doc = "< [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set."]
    #[doc = "Will be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH."]
    pub intraRefreshPeriod: u32,
    #[doc = "< [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod"]
    pub intraRefreshCnt: u32,
    #[doc = "< [in]: Specifies the maximum number of references frames in the DPB."]
    pub maxNumRefFramesInDPB: u32,
    #[doc = "< [in]: This parameter has different meaning in two LTR modes."]
    #[doc = "In \"LTR Trust\" mode (ltrTrustMode = 1), encoder will mark the first ltrNumFrames base layer reference frames within each IDR interval as LTR."]
    #[doc = "In \"LTR Per Picture\" mode (ltrTrustMode = 0 and ltrMarkFrame = 1), ltrNumFrames specifies maximum number of LTR frames in DPB."]
    pub ltrNumFrames: u32,
    #[doc = "< [in]: Specifies the VPS id of the video parameter set"]
    pub vpsId: u32,
    #[doc = "< [in]: Specifies the SPS id of the sequence header"]
    pub spsId: u32,
    #[doc = "< [in]: Specifies the PPS id of the picture header"]
    pub ppsId: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 CTU based slices, sliceMode = 1 Byte based slices, sliceMode = 2 CTU row based slices, sliceMode = 3, numSlices in Picture"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of CTUs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of CTU rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the max temporal layer used for hierarchical coding."]
    pub maxTemporalLayersMinus1: u32,
    #[doc = "< [in]: Specifies the HEVC video usability info parameters"]
    pub hevcVUIParameters: NV_ENC_CONFIG_HEVC_VUI_PARAMETERS,
    #[doc = "< [in]: Specifies the LTR operating mode. See comments near NV_ENC_CONFIG_HEVC::enableLTR for description of the two modes."]
    #[doc = "Set to 1 to use \"LTR Trust\" mode of LTR operation. Clients are discouraged to use \"LTR Trust\" mode as this mode may"]
    #[doc = "be deprecated in future releases."]
    #[doc = "Set to 0 when using \"LTR Per Picture\" mode of LTR operation."]
    pub ltrTrustMode: u32,
    #[doc = "< [in]: Specifies the B-Frame as reference mode. Check support for useBFramesAsRef mode using  ::NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE caps."]
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL0 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL1 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 214usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_HEVC() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_HEVC>(),
        1560usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_HEVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_HEVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_HEVC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).tier as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(tier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).minCUSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(minCUSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).maxCUSize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxCUSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).idrPeriod as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).intraRefreshPeriod as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).intraRefreshCnt as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).maxNumRefFramesInDPB as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxNumRefFramesInDPB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).ltrNumFrames as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ltrNumFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).vpsId as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(vpsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).spsId as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).ppsId as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).sliceMode as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).sliceModeData as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).maxTemporalLayersMinus1 as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxTemporalLayersMinus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).hevcVUIParameters as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(hevcVUIParameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).ltrTrustMode as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ltrTrustMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).useBFramesAsRef as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).numRefL0 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(numRefL0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).numRefL1 as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(numRefL1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).reserved2 as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_CONFIG_HEVC {
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableDeblockAcrossSliceBoundary(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableDeblockAcrossSliceBoundary(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelBitDepthMinus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pixelBitDepthMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableAlphaLayerEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAlphaLayerEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        useConstrainedIntraPred: u32,
        disableDeblockAcrossSliceBoundary: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        enableLTR: u32,
        disableSPSPPS: u32,
        repeatSPSPPS: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        pixelBitDepthMinus8: u32,
        enableFillerDataInsertion: u32,
        enableConstrainedEncoding: u32,
        enableAlphaLayerEncoding: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disableDeblockAcrossSliceBoundary: u32 =
                unsafe { ::std::mem::transmute(disableDeblockAcrossSliceBoundary) };
            disableDeblockAcrossSliceBoundary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::std::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let pixelBitDepthMinus8: u32 = unsafe { ::std::mem::transmute(pixelBitDepthMinus8) };
            pixelBitDepthMinus8 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::std::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::std::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let enableAlphaLayerEncoding: u32 =
                unsafe { ::std::mem::transmute(enableAlphaLayerEncoding) };
            enableAlphaLayerEncoding as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_HEVC"]
#[doc = " HEVC encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CONFIG_HEVC = _NV_ENC_CONFIG_HEVC;
#[doc = " \\struct _NV_ENC_CONFIG_H264_MEONLY"]
#[doc = " H264 encoder configuration parameters for ME only Mode"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG_H264_MEONLY {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264_MEONLY() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264_MEONLY>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264_MEONLY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264_MEONLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_H264_MEONLY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_MEONLY>())).reserved1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_MEONLY),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_MEONLY>())).reserved2 as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_MEONLY),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_CONFIG_H264_MEONLY {
    #[inline]
    pub fn disablePartition16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableIntraSearch(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIntraSearch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bStereoEnable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bStereoEnable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disablePartition16x16: u32,
        disablePartition8x16: u32,
        disablePartition16x8: u32,
        disablePartition8x8: u32,
        disableIntraSearch: u32,
        bStereoEnable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disablePartition16x16: u32 =
                unsafe { ::std::mem::transmute(disablePartition16x16) };
            disablePartition16x16 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disablePartition8x16: u32 = unsafe { ::std::mem::transmute(disablePartition8x16) };
            disablePartition8x16 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disablePartition16x8: u32 = unsafe { ::std::mem::transmute(disablePartition16x8) };
            disablePartition16x8 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disablePartition8x8: u32 = unsafe { ::std::mem::transmute(disablePartition8x8) };
            disablePartition8x8 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableIntraSearch: u32 = unsafe { ::std::mem::transmute(disableIntraSearch) };
            disableIntraSearch as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bStereoEnable: u32 = unsafe { ::std::mem::transmute(bStereoEnable) };
            bStereoEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_H264_MEONLY"]
#[doc = " H264 encoder configuration parameters for ME only Mode"]
#[doc = ""]
pub type NV_ENC_CONFIG_H264_MEONLY = _NV_ENC_CONFIG_H264_MEONLY;
#[doc = " \\struct _NV_ENC_CONFIG_HEVC_MEONLY"]
#[doc = " HEVC encoder configuration parameters for ME only Mode"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG_HEVC_MEONLY {
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 256usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved1: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_HEVC_MEONLY() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_HEVC_MEONLY>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_HEVC_MEONLY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_HEVC_MEONLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_HEVC_MEONLY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC_MEONLY>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC_MEONLY),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC_MEONLY>())).reserved1 as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC_MEONLY),
            "::",
            stringify!(reserved1)
        )
    );
}
#[doc = " \\struct _NV_ENC_CONFIG_HEVC_MEONLY"]
#[doc = " HEVC encoder configuration parameters for ME only Mode"]
#[doc = ""]
pub type NV_ENC_CONFIG_HEVC_MEONLY = _NV_ENC_CONFIG_HEVC_MEONLY;
#[doc = " \\struct _NV_ENC_CODEC_CONFIG"]
#[doc = " Codec-specific encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_CONFIG {
    #[doc = "< [in]: Specifies the H.264-specific encoder configuration."]
    pub h264Config: NV_ENC_CONFIG_H264,
    #[doc = "< [in]: Specifies the HEVC-specific encoder configuration."]
    pub hevcConfig: NV_ENC_CONFIG_HEVC,
    #[doc = "< [in]: Specifies the H.264-specific ME only encoder configuration."]
    pub h264MeOnlyConfig: NV_ENC_CONFIG_H264_MEONLY,
    #[doc = "< [in]: Specifies the HEVC-specific ME only encoder configuration."]
    pub hevcMeOnlyConfig: NV_ENC_CONFIG_HEVC_MEONLY,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 320usize],
    _bindgen_union_align: [u64; 224usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CODEC_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CODEC_CONFIG>(),
        1792usize,
        concat!("Size of: ", stringify!(_NV_ENC_CODEC_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CODEC_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CODEC_CONFIG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).h264Config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(h264Config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).hevcConfig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(hevcConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).h264MeOnlyConfig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(h264MeOnlyConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).hevcMeOnlyConfig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(hevcMeOnlyConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " \\struct _NV_ENC_CODEC_CONFIG"]
#[doc = " Codec-specific encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CODEC_CONFIG = _NV_ENC_CODEC_CONFIG;
#[doc = " \\struct _NV_ENC_CONFIG"]
#[doc = " Encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CONFIG_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the codec profile GUID. If client specifies \\p NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID the NvEncodeAPI interface will select the appropriate codec profile."]
    pub profileGUID: GUID,
    #[doc = "< [in]: Specifies the number of pictures in one GOP. Low latency application client can set goplength to NVENC_INFINITE_GOPLENGTH so that keyframes are not inserted automatically."]
    pub gopLength: u32,
    #[doc = "< [in]: Specifies the GOP pattern as follows: \\p frameIntervalP = 0: I, 1: IPP, 2: IBP, 3: IBBP  If goplength is set to NVENC_INFINITE_GOPLENGTH \\p frameIntervalP should be set to 1."]
    pub frameIntervalP: i32,
    #[doc = "< [in]: Set this to 1 to enable monochrome encoding for this session."]
    pub monoChromeEncoding: u32,
    #[doc = "< [in]: Specifies the frame/field mode."]
    #[doc = "Check support for field encoding using ::NV_ENC_CAPS_SUPPORT_FIELD_ENCODING caps."]
    #[doc = "Using a frameFieldMode other than NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME for RGB input is not supported."]
    pub frameFieldMode: NV_ENC_PARAMS_FRAME_FIELD_MODE,
    #[doc = "< [in]: Specifies the desired motion vector prediction precision."]
    pub mvPrecision: NV_ENC_MV_PRECISION,
    #[doc = "< [in]: Specifies the rate control parameters for the current encoding session."]
    pub rcParams: NV_ENC_RC_PARAMS,
    #[doc = "< [in]: Specifies the codec specific config parameters through this union."]
    pub encodeCodecConfig: NV_ENC_CODEC_CONFIG,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 278usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG>(),
        3584usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).profileGUID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(profileGUID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).gopLength as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(gopLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).frameIntervalP as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(frameIntervalP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).monoChromeEncoding as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(monoChromeEncoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).frameFieldMode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(frameFieldMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).mvPrecision as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(mvPrecision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).rcParams as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(rcParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).encodeCodecConfig as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(encodeCodecConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).reserved as *const _ as usize },
        1960usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).reserved2 as *const _ as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_CONFIG"]
#[doc = " Encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CONFIG = _NV_ENC_CONFIG;
pub mod NV_ENC_TUNING_INFO {
    #[doc = "  Tuning information of NVENC encoding (TuningInfo is not applicable to H264 and HEVC MEOnly mode)."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "< Undefined tuningInfo. Invalid value for encoding."]
    pub const NV_ENC_TUNING_INFO_UNDEFINED: Type = 0;
    #[doc = "< Tune presets for latency tolerant encoding."]
    pub const NV_ENC_TUNING_INFO_HIGH_QUALITY: Type = 1;
    #[doc = "< Tune presets for low latency streaming."]
    pub const NV_ENC_TUNING_INFO_LOW_LATENCY: Type = 2;
    #[doc = "< Tune presets for ultra low latency streaming."]
    pub const NV_ENC_TUNING_INFO_ULTRA_LOW_LATENCY: Type = 3;
    #[doc = "< Tune presets for lossless encoding."]
    pub const NV_ENC_TUNING_INFO_LOSSLESS: Type = 4;
    #[doc = "< Count number of tuningInfos. Invalid value."]
    pub const NV_ENC_TUNING_INFO_COUNT: Type = 5;
}
#[doc = " \\struct _NV_ENC_INITIALIZE_PARAMS"]
#[doc = " Encode Session Initialization parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_INITIALIZE_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_INITIALIZE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the Encode GUID for which the encoder is being created. ::NvEncInitializeEncoder() API will fail if this is not set, or set to unsupported value."]
    pub encodeGUID: GUID,
    #[doc = "< [in]: Specifies the preset for encoding. If the preset GUID is set then , the preset configuration will be applied before any other parameter."]
    pub presetGUID: GUID,
    #[doc = "< [in]: Specifies the encode width. If not set ::NvEncInitializeEncoder() API will fail."]
    pub encodeWidth: u32,
    #[doc = "< [in]: Specifies the encode height. If not set ::NvEncInitializeEncoder() API will fail."]
    pub encodeHeight: u32,
    #[doc = "< [in]: Specifies the display aspect ratio Width."]
    pub darWidth: u32,
    #[doc = "< [in]: Specifies the display aspect ratio height."]
    pub darHeight: u32,
    #[doc = "< [in]: Specifies the numerator for frame rate used for encoding in frames per second ( Frame rate = frameRateNum / frameRateDen )."]
    pub frameRateNum: u32,
    #[doc = "< [in]: Specifies the denominator for frame rate used for encoding in frames per second ( Frame rate = frameRateNum / frameRateDen )."]
    pub frameRateDen: u32,
    #[doc = "< [in]: Set this to 1 to enable asynchronous mode and is expected to use events to get picture completion notification."]
    pub enableEncodeAsync: u32,
    #[doc = "< [in]: Set this to 1 to enable the Picture Type Decision is be taken by the NvEncodeAPI interface."]
    pub enablePTD: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]: Reserved private data buffer size and must be set to 0"]
    pub privDataSize: u32,
    #[doc = "< [in]: Reserved private data buffer and must be set to NULL"]
    pub privData: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies the advanced codec specific structure. If client has sent a valid codec config structure, it will override parameters set by the NV_ENC_INITIALIZE_PARAMS::presetGUID parameter. If set to NULL the NvEncodeAPI interface will use the NV_ENC_INITIALIZE_PARAMS::presetGUID to set the codec specific parameters."]
    #[doc = "Client can also optionally query the NvEncodeAPI interface to get codec specific parameters for a presetGUID using ::NvEncGetEncodePresetConfig() API. It can then modify (if required) some of the codec config parameters and send down a custom config structure as part of ::_NV_ENC_INITIALIZE_PARAMS."]
    #[doc = "Even in this case client is recommended to pass the same preset guid it has used in ::NvEncGetEncodePresetConfig() API to query the config structure; as NV_ENC_INITIALIZE_PARAMS::presetGUID. This will not override the custom config structure but will be used to determine other Encoder HW specific parameters not exposed in the API."]
    pub encodeConfig: *mut NV_ENC_CONFIG,
    #[doc = "< [in]: Maximum encode width to be used for current Encode session."]
    #[doc = "Client should allocate output buffers according to this dimension for dynamic resolution change. If set to 0, Encoder will not allow dynamic resolution change."]
    pub maxEncodeWidth: u32,
    #[doc = "< [in]: Maximum encode height to be allowed for current Encode session."]
    #[doc = "Client should allocate output buffers according to this dimension for dynamic resolution change. If set to 0, Encode will not allow dynamic resolution change."]
    pub maxEncodeHeight: u32,
    #[doc = "< [in]: If Client wants to pass external motion vectors in NV_ENC_PIC_PARAMS::meExternalHints buffer it must specify the maximum number of hint candidates per block per direction for the encode session."]
    #[doc = "The NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[0] is for L0 predictors and NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[1] is for L1 predictors."]
    #[doc = "This client must also set NV_ENC_INITIALIZE_PARAMS::enableExternalMEHints to 1."]
    pub maxMEHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: Tuning Info of NVENC encoding(TuningInfo is not applicable to H264 and HEVC meonly mode)."]
    pub tuningInfo: NV_ENC_TUNING_INFO::Type,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 288usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_INITIALIZE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_INITIALIZE_PARAMS>(),
        1808usize,
        concat!("Size of: ", stringify!(_NV_ENC_INITIALIZE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_INITIALIZE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_INITIALIZE_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeGUID as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeGUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).presetGUID as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(presetGUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeWidth as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeHeight as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).darWidth as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(darWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).darHeight as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(darHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).frameRateNum as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(frameRateNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).frameRateDen as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(frameRateDen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).enableEncodeAsync as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(enableEncodeAsync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).enablePTD as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(enablePTD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).privDataSize as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(privDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).privData as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(privData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeConfig as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).maxEncodeWidth as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxEncodeWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).maxEncodeHeight as *const _
                as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxEncodeHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).maxMEHintCountsPerBlock
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxMEHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).tuningInfo as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(tuningInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).reserved as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).reserved2 as *const _ as usize
        },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_INITIALIZE_PARAMS {
    #[inline]
    pub fn reportSliceOffsets(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reportSliceOffsets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableSubFrameWrite(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableSubFrameWrite(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableExternalMEHints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableExternalMEHints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableMEOnlyMode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMEOnlyMode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableWeightedPrediction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableWeightedPrediction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableOutputInVidmem(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableOutputInVidmem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reportSliceOffsets: u32,
        enableSubFrameWrite: u32,
        enableExternalMEHints: u32,
        enableMEOnlyMode: u32,
        enableWeightedPrediction: u32,
        enableOutputInVidmem: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reportSliceOffsets: u32 = unsafe { ::std::mem::transmute(reportSliceOffsets) };
            reportSliceOffsets as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableSubFrameWrite: u32 = unsafe { ::std::mem::transmute(enableSubFrameWrite) };
            enableSubFrameWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableExternalMEHints: u32 =
                unsafe { ::std::mem::transmute(enableExternalMEHints) };
            enableExternalMEHints as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableMEOnlyMode: u32 = unsafe { ::std::mem::transmute(enableMEOnlyMode) };
            enableMEOnlyMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enableWeightedPrediction: u32 =
                unsafe { ::std::mem::transmute(enableWeightedPrediction) };
            enableWeightedPrediction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableOutputInVidmem: u32 = unsafe { ::std::mem::transmute(enableOutputInVidmem) };
            enableOutputInVidmem as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_INITIALIZE_PARAMS"]
#[doc = " Encode Session Initialization parameters."]
pub type NV_ENC_INITIALIZE_PARAMS = _NV_ENC_INITIALIZE_PARAMS;
#[doc = " \\struct _NV_ENC_RECONFIGURE_PARAMS"]
#[doc = " Encode Session Reconfigured parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_RECONFIGURE_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_RECONFIGURE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Encoder session re-initialization parameters."]
    #[doc = "If reInitEncodeParams.encodeConfig is NULL and"]
    #[doc = "reInitEncodeParams.presetGUID is the same as the preset"]
    #[doc = "GUID specified on the call to NvEncInitializeEncoder(),"]
    #[doc = "EncodeAPI will continue to use the existing encode"]
    #[doc = "configuration."]
    #[doc = "If reInitEncodeParams.encodeConfig is NULL and"]
    #[doc = "reInitEncodeParams.presetGUID is different from the preset"]
    #[doc = "GUID specified on the call to NvEncInitializeEncoder(),"]
    #[doc = "EncodeAPI will try to use the default configuration for"]
    #[doc = "the preset specified by reInitEncodeParams.presetGUID."]
    #[doc = "In this case, reconfiguration may fail if the new"]
    #[doc = "configuration is incompatible with the existing"]
    #[doc = "configuration (e.g. the new configuration results in"]
    #[doc = "a change in the GOP structure)."]
    pub reInitEncodeParams: NV_ENC_INITIALIZE_PARAMS,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_RECONFIGURE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_RECONFIGURE_PARAMS>(),
        1824usize,
        concat!("Size of: ", stringify!(_NV_ENC_RECONFIGURE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_RECONFIGURE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_RECONFIGURE_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RECONFIGURE_PARAMS>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RECONFIGURE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RECONFIGURE_PARAMS>())).reInitEncodeParams as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RECONFIGURE_PARAMS),
            "::",
            stringify!(reInitEncodeParams)
        )
    );
}
impl _NV_ENC_RECONFIGURE_PARAMS {
    #[inline]
    pub fn resetEncoder(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resetEncoder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceIDR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceIDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        resetEncoder: u32,
        forceIDR: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let resetEncoder: u32 = unsafe { ::std::mem::transmute(resetEncoder) };
            resetEncoder as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let forceIDR: u32 = unsafe { ::std::mem::transmute(forceIDR) };
            forceIDR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_RECONFIGURE_PARAMS"]
#[doc = " Encode Session Reconfigured parameters."]
pub type NV_ENC_RECONFIGURE_PARAMS = _NV_ENC_RECONFIGURE_PARAMS;
#[doc = " \\struct _NV_ENC_PRESET_CONFIG"]
#[doc = " Encoder preset config"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PRESET_CONFIG {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_PRESET_CONFIG_VER."]
    pub version: u32,
    #[doc = "< [out]: preset config returned by the Nvidia Video Encoder interface."]
    pub presetCfg: NV_ENC_CONFIG,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PRESET_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PRESET_CONFIG>(),
        5128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PRESET_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PRESET_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PRESET_CONFIG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).presetCfg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(presetCfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).reserved1 as *const _ as usize },
        3592usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).reserved2 as *const _ as usize },
        4616usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_PRESET_CONFIG"]
#[doc = " Encoder preset config"]
pub type NV_ENC_PRESET_CONFIG = _NV_ENC_PRESET_CONFIG;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_MVC"]
#[doc = " MVC-specific parameters to be sent on a per-frame basis."]
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_MVC {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_PIC_PARAMS_MVC_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the view ID associated with the current input view."]
    pub viewID: u32,
    #[doc = "< [in]: Specifies the temporal ID associated with the current input view."]
    pub temporalID: u32,
    #[doc = "< [in]: Specifies the priority ID associated with the current input view. Reserved and ignored by the NvEncodeAPI interface."]
    pub priorityID: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 12usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 8usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_MVC() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_MVC>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_MVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_MVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_MVC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).viewID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(viewID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).temporalID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(temporalID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).priorityID as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(priorityID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).reserved1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).reserved2 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_MVC"]
#[doc = " MVC-specific parameters to be sent on a per-frame basis."]
pub type NV_ENC_PIC_PARAMS_MVC = _NV_ENC_PIC_PARAMS_MVC;
#[doc = " \\union _NV_ENC_PIC_PARAMS_H264_EXT"]
#[doc = " H264 extension  picture parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_PIC_PARAMS_H264_EXT {
    #[doc = "< [in]: Specifies the MVC picture parameters."]
    pub mvcPicParams: NV_ENC_PIC_PARAMS_MVC,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 32usize],
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_H264_EXT() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_H264_EXT>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_H264_EXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_H264_EXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_H264_EXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264_EXT>())).mvcPicParams as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264_EXT),
            "::",
            stringify!(mvcPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264_EXT>())).reserved1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264_EXT),
            "::",
            stringify!(reserved1)
        )
    );
}
#[doc = " \\union _NV_ENC_PIC_PARAMS_H264_EXT"]
#[doc = " H264 extension  picture parameters"]
pub type NV_ENC_PIC_PARAMS_H264_EXT = _NV_ENC_PIC_PARAMS_H264_EXT;
#[doc = " \\struct _NV_ENC_SEI_PAYLOAD"]
#[doc = "  User SEI message"]
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NV_ENC_SEI_PAYLOAD {
    #[doc = "< [in] SEI payload size in bytes. SEI payload must be byte aligned, as described in Annex D"]
    pub payloadSize: u32,
    #[doc = "< [in] SEI payload types and syntax can be found in Annex D of the H.264 Specification."]
    pub payloadType: u32,
    #[doc = "< [in] pointer to user data"]
    pub payload: *mut u8,
}
#[test]
fn bindgen_test_layout__NV_ENC_SEI_PAYLOAD() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_SEI_PAYLOAD>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_ENC_SEI_PAYLOAD))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_SEI_PAYLOAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_SEI_PAYLOAD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_SEI_PAYLOAD>())).payloadSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payloadSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_SEI_PAYLOAD>())).payloadType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payloadType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_SEI_PAYLOAD>())).payload as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payload)
        )
    );
}
#[doc = " \\struct _NV_ENC_SEI_PAYLOAD"]
#[doc = "  User SEI message"]
pub type NV_ENC_SEI_PAYLOAD = _NV_ENC_SEI_PAYLOAD;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_H264"]
#[doc = " H264 specific enc pic params. sent on a per frame basis."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_H264 {
    #[doc = "< [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision."]
    pub displayPOCSyntax: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved3: u32,
    #[doc = "< [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1."]
    pub refPicFlag: u32,
    #[doc = "< [in]: Specifies the colour plane ID associated with the current input."]
    pub colourPlaneId: u32,
    #[doc = "< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt."]
    #[doc = "When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message"]
    #[doc = "forceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified"]
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]: Deprecated."]
    pub sliceTypeData: *mut u8,
    #[doc = "< [in]: Deprecated."]
    pub sliceTypeArrayCnt: u32,
    #[doc = "< [in]: Specifies the number of elements allocated in  seiPayloadArray array."]
    pub seiPayloadArrayCnt: u32,
    #[doc = "< [in]: Array of SEI payloads which will be inserted for this frame."]
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 MB based slices, sliceMode = 1 Byte based slices, sliceMode = 2 MB row based slices, sliceMode = 3, numSlices in Picture"]
    #[doc = "When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of MBs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of MB rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the long term referenceframe index to use for marking this frame as LTR."]
    pub ltrMarkFrameIdx: u32,
    #[doc = "< [in]: Specifies the associated bitmap of LTR frame indices to use when encoding this frame."]
    pub ltrUseFrameBitmap: u32,
    #[doc = "< [in]: Not supported. Reserved for future use and must be set to 0."]
    pub ltrUsageMode: u32,
    #[doc = "< [in]: Specifies the number of slices to be forced to Intra in the current picture."]
    #[doc = "This option along with forceIntraSliceIdx[] array needs to be used with sliceMode = 3 only"]
    pub forceIntraSliceCount: u32,
    #[doc = "< [in]: Slice indices to be forced to intra in the current picture. Each slice index should be <= num_slices_in_picture -1. Index starts from 0 for first slice."]
    #[doc = "The number of entries in this array should be equal to forceIntraSliceCount"]
    pub forceIntraSliceIdx: *mut u32,
    #[doc = "< [in]: Specifies the H264 extension config parameters using this config."]
    pub h264ExtPicParams: NV_ENC_PIC_PARAMS_H264_EXT,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: [u32; 210usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 61usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_H264() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_H264>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_H264))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_H264>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_H264))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).displayPOCSyntax as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).reserved3 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).refPicFlag as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).colourPlaneId as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(colourPlaneId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).forceIntraRefreshWithFrameCnt
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceTypeData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceTypeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceTypeArrayCnt as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceTypeArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).seiPayloadArrayCnt as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(seiPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).seiPayloadArray as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(seiPayloadArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceMode as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceModeData as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).ltrMarkFrameIdx as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrMarkFrameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).ltrUseFrameBitmap as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrUseFrameBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).ltrUsageMode as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrUsageMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).forceIntraSliceCount as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraSliceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).forceIntraSliceIdx as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraSliceIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).h264ExtPicParams as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(h264ExtPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).reserved as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).reserved2 as *const _ as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_PIC_PARAMS_H264 {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_H264"]
#[doc = " H264 specific enc pic params. sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS_H264 = _NV_ENC_PIC_PARAMS_H264;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_HEVC"]
#[doc = " HEVC specific enc pic params. sent on a per frame basis."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_HEVC {
    #[doc = "< [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision."]
    pub displayPOCSyntax: u32,
    #[doc = "< [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1."]
    pub refPicFlag: u32,
    #[doc = "< [in]: Specifies the temporal id of the picture"]
    pub temporalId: u32,
    #[doc = "< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt."]
    #[doc = "When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message"]
    #[doc = "forceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified"]
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]: Array which specifies the slice type used to force intra slice for a particular slice. Currently supported only for NV_ENC_CONFIG_H264::sliceMode == 3."]
    #[doc = "Client should allocate array of size sliceModeData where sliceModeData is specified in field of ::_NV_ENC_CONFIG_H264"]
    #[doc = "Array element with index n corresponds to nth slice. To force a particular slice to intra client should set corresponding array element to NV_ENC_SLICE_TYPE_I"]
    #[doc = "all other array elements should be set to NV_ENC_SLICE_TYPE_DEFAULT"]
    pub sliceTypeData: *mut u8,
    #[doc = "< [in]: Client should set this to the number of elements allocated in sliceTypeData array. If sliceTypeData is NULL then this should be set to 0"]
    pub sliceTypeArrayCnt: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 CTU based slices, sliceMode = 1 Byte based slices, sliceMode = 2 CTU row based slices, sliceMode = 3, numSlices in Picture"]
    #[doc = "When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of CTUs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of CTU rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the long term reference frame index to use for marking this frame as LTR."]
    pub ltrMarkFrameIdx: u32,
    #[doc = "< [in]: Specifies the associated bitmap of LTR frame indices to use when encoding this frame."]
    pub ltrUseFrameBitmap: u32,
    #[doc = "< [in]: Not supported. Reserved for future use and must be set to 0."]
    pub ltrUsageMode: u32,
    #[doc = "< [in]: Specifies the number of elements allocated in  seiPayloadArray array."]
    pub seiPayloadArrayCnt: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: u32,
    #[doc = "< [in]: Array of SEI payloads which will be inserted for this frame."]
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved2: [u32; 244usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved3: [*mut ::std::os::raw::c_void; 61usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_HEVC() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_HEVC>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_HEVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_HEVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_HEVC))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).displayPOCSyntax as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).refPicFlag as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).temporalId as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(temporalId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).forceIntraRefreshWithFrameCnt
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceTypeData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceTypeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceTypeArrayCnt as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceTypeArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceMode as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceModeData as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).ltrMarkFrameIdx as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrMarkFrameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).ltrUseFrameBitmap as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrUseFrameBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).ltrUsageMode as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrUsageMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).seiPayloadArrayCnt as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(seiPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).reserved as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).seiPayloadArray as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(seiPayloadArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).reserved2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).reserved3 as *const _ as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved3)
        )
    );
}
impl _NV_ENC_PIC_PARAMS_HEVC {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_HEVC"]
#[doc = " HEVC specific enc pic params. sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS_HEVC = _NV_ENC_PIC_PARAMS_HEVC;
#[doc = " Codec specific per-picture encoding parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_PIC_PARAMS {
    #[doc = "< [in]: H264 encode picture params."]
    pub h264PicParams: NV_ENC_PIC_PARAMS_H264,
    #[doc = "< [in]: HEVC encode picture params."]
    pub hevcPicParams: NV_ENC_PIC_PARAMS_HEVC,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: [u32; 256usize],
    _bindgen_union_align: [u64; 192usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CODEC_PIC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CODEC_PIC_PARAMS>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CODEC_PIC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CODEC_PIC_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CODEC_PIC_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_PIC_PARAMS>())).h264PicParams as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(h264PicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_PIC_PARAMS>())).hevcPicParams as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(hevcPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_PIC_PARAMS>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Codec specific per-picture encoding parameters."]
pub type NV_ENC_CODEC_PIC_PARAMS = _NV_ENC_CODEC_PIC_PARAMS;
#[doc = " \\struct _NV_ENC_PIC_PARAMS"]
#[doc = " Encoding parameters that need to be sent on a per frame basis."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_PIC_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the input frame width"]
    pub inputWidth: u32,
    #[doc = "< [in]: Specifies the input frame height"]
    pub inputHeight: u32,
    #[doc = "< [in]: Specifies the input buffer pitch. If pitch value is not known, set this to inputWidth."]
    pub inputPitch: u32,
    #[doc = "< [in]: Specifies bit-wise OR of encode picture flags. See ::NV_ENC_PIC_FLAGS enum."]
    pub encodePicFlags: u32,
    #[doc = "< [in]: Specifies the frame index associated with the input frame [optional]."]
    pub frameIdx: u32,
    #[doc = "< [in]: Specifies opaque data which is associated with the encoded frame, but not actually encoded in the output bitstream."]
    #[doc = "This opaque data can be used later to uniquely refer to the corresponding encoded frame. For example, it can be used"]
    #[doc = "for identifying the frame to be invalidated in the reference picture buffer, if lost at the client."]
    pub inputTimeStamp: u64,
    #[doc = "< [in]: Specifies duration of the input picture"]
    pub inputDuration: u64,
    #[doc = "< [in]: Specifies the input buffer pointer. Client must use a pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource() APIs."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the output buffer pointer."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to output buffer. Client should use a pointer obtained from ::NvEncCreateBitstreamBuffer() API."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for NV_ENC_ENCODE_OUT_PARAMS struct and encoded bitstream data. Client"]
    #[doc = "should use a pointer obtained from ::NvEncMapInputResource() API, when mapping this output buffer and assign it to NV_ENC_PIC_PARAMS::outputBitstream."]
    #[doc = "First 256 bytes of this buffer should be interpreted as NV_ENC_ENCODE_OUT_PARAMS struct followed by encoded bitstream data. Recommended size for output buffer is sum of size of"]
    #[doc = "NV_ENC_ENCODE_OUT_PARAMS struct and twice the input frame size for lower resolution eg. CIF and 1.5 times the input frame size for higher resolutions. If encoded bitstream size is"]
    #[doc = "greater than the allocated buffer size for encoded bitstream, then the output buffer will have encoded bitstream data equal to buffer size. All CUDA operations on this buffer must use"]
    #[doc = "the default stream."]
    pub outputBitstream: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Specifies an event to be signaled on completion of encoding of this Frame [only if operating in Asynchronous mode]. Each output buffer should be associated with a distinct event pointer."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies the input buffer format."]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Specifies structure of the input picture."]
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    #[doc = "< [in]: Specifies input picture type. Client required to be set explicitly by the client if the client has not set NV_ENC_INITALIZE_PARAMS::enablePTD to 1 while calling NvInitializeEncoder."]
    pub pictureType: NV_ENC_PIC_TYPE,
    #[doc = "< [in]: Specifies the codec specific per-picture encoding parameters."]
    pub codecPicParams: NV_ENC_CODEC_PIC_PARAMS,
    #[doc = "< [in]: Specifies the number of hint candidates per block per direction for the current frame. meHintCountsPerBlock[0] is for L0 predictors and meHintCountsPerBlock[1] is for L1 predictors."]
    #[doc = "The candidate count in NV_ENC_PIC_PARAMS::meHintCountsPerBlock[lx] must never exceed NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[lx] provided during encoder initialization."]
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks * the total number of candidates per macroblock."]
    #[doc = "The total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8"]
    #[doc = "+ 4*meHintCountsPerBlock[Lx].numCandsPerBlk8x8. For frames using bidirectional ME , the total number of candidates for single macroblock is sum of total number of candidates per MB for each direction (L0 and L1)"]
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 6usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 2usize],
    #[doc = "< [in]: Specifies the pointer to signed byte array containing value per MB for H264 and per CTB for HEVC in raster scan order for the current picture, which will be interpreted depending on NV_ENC_RC_PARAMS::qpMapMode."]
    #[doc = "If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_DELTA, qpDeltaMap specifies QP modifier per MB for H264 and per CTB for HEVC. This QP modifier will be applied on top of the QP chosen by rate control."]
    #[doc = "If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_EMPHASIS, qpDeltaMap specifies Emphasis Level Map per MB for H264. This level value along with QP chosen by rate control is used to"]
    #[doc = "compute the QP modifier, which in turn is applied on top of QP chosen by rate control."]
    #[doc = "If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_DISABLED, value in qpDeltaMap will be ignored."]
    pub qpDeltaMap: *mut i8,
    #[doc = "< [in]: Specifies the size in bytes of qpDeltaMap surface allocated by client and pointed to by NV_ENC_PIC_PARAMS::qpDeltaMap. Surface (array) should be picWidthInMbs * picHeightInMbs for H264 and picWidthInCtbs * picHeightInCtbs for HEVC"]
    pub qpDeltaMapSize: u32,
    #[doc = "< [in]: Reserved bitfields and must be set to 0"]
    pub reservedBitFields: u32,
    #[doc = "< [in]: Specifies temporal distance for reference picture (NVENC_EXTERNAL_ME_HINT::refidx = 0) used during external ME with NV_ENC_INITALIZE_PARAMS::enablePTD = 1 . meHintRefPicDist[0] is for L0 hints and meHintRefPicDist[1] is for L1 hints."]
    #[doc = "If not set, will internally infer distance of 1. Ignored for NV_ENC_INITALIZE_PARAMS::enablePTD = 0"]
    pub meHintRefPicDist: [u16; 2usize],
    #[doc = "< [in]: Specifies the input alpha buffer pointer. Client must use a pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource() APIs."]
    #[doc = "Applicable only when encoding hevc with alpha layer is enabled."]
    pub alphaBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved3: [u32; 286usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved4: [*mut ::std::os::raw::c_void; 59usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS>(),
        3344usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputWidth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputHeight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputPitch as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputPitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).encodePicFlags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(encodePicFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).frameIdx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(frameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputTimeStamp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputTimeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputDuration as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputDuration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputBuffer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).outputBitstream as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(outputBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).completionEvent as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).bufferFmt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).pictureStruct as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(pictureStruct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).pictureType as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(pictureType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).codecPicParams as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(codecPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).meHintCountsPerBlock as *const _ as usize
        },
        1616usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).meExternalHints as *const _ as usize
        },
        1648usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meExternalHints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved1 as *const _ as usize },
        1656usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved2 as *const _ as usize },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).qpDeltaMap as *const _ as usize },
        1696usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(qpDeltaMap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).qpDeltaMapSize as *const _ as usize
        },
        1704usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(qpDeltaMapSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reservedBitFields as *const _ as usize
        },
        1708usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reservedBitFields)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).meHintRefPicDist as *const _ as usize
        },
        1712usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meHintRefPicDist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).alphaBuffer as *const _ as usize },
        1720usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(alphaBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved3 as *const _ as usize },
        1728usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved4 as *const _ as usize },
        2872usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved4)
        )
    );
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS"]
#[doc = " Encoding parameters that need to be sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS = _NV_ENC_PIC_PARAMS;
#[doc = " \\struct _NV_ENC_MEONLY_PARAMS"]
#[doc = " MEOnly parameters that need to be sent on a per motion estimation basis."]
#[doc = " NV_ENC_MEONLY_PARAMS::meExternalHints is supported for H264 only."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_MEONLY_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to NV_ENC_MEONLY_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the input frame width"]
    pub inputWidth: u32,
    #[doc = "< [in]: Specifies the input frame height"]
    pub inputHeight: u32,
    #[doc = "< [in]: Specifies the input buffer pointer. Client must use a pointer obtained from NvEncCreateInputBuffer() or NvEncMapInputResource() APIs."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the reference frame pointer"]
    pub referenceFrame: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the output buffer pointer."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to motion vector data buffer allocated by NvEncCreateMVBuffer."]
    #[doc = "Client must lock mvBuffer using ::NvEncLockBitstream() API to get the motion vector data."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for storing the motion vector data. The size of this buffer must"]
    #[doc = "be equal to total number of macroblocks multiplied by size of NV_ENC_H264_MV_DATA struct. Client should use a pointer obtained from ::NvEncMapInputResource() API, when mapping this"]
    #[doc = "output buffer and assign it to NV_ENC_MEONLY_PARAMS::mvBuffer. All CUDA operations on this buffer must use the default stream."]
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Specifies the input buffer format."]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Specifies an event to be signaled on completion of motion estimation"]
    #[doc = "of this Frame [only if operating in Asynchronous mode]."]
    #[doc = "Each output buffer should be associated with a distinct event pointer."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies left or right viewID if NV_ENC_CONFIG_H264_MEONLY::bStereoEnable is set."]
    #[doc = "viewID can be 0,1 if bStereoEnable is set, 0 otherwise."]
    pub viewID: u32,
    #[doc = "< [in]: Specifies the number of hint candidates per block for the current frame. meHintCountsPerBlock[0] is for L0 predictors."]
    #[doc = "The candidate count in NV_ENC_PIC_PARAMS::meHintCountsPerBlock[lx] must never exceed NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[lx] provided during encoder initialization."]
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks * the total number of candidates per macroblock."]
    #[doc = "The total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8"]
    #[doc = "+ 4*meHintCountsPerBlock[Lx].numCandsPerBlk8x8. For frames using bidirectional ME , the total number of candidates for single macroblock is sum of total number of candidates per MB for each direction (L0 and L1)"]
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 243usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 59usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_MEONLY_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_MEONLY_PARAMS>(),
        1552usize,
        concat!("Size of: ", stringify!(_NV_ENC_MEONLY_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_MEONLY_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MEONLY_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).inputWidth as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).inputHeight as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).inputBuffer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).referenceFrame as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(referenceFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).mvBuffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(mvBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).bufferFmt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).completionEvent as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).viewID as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(viewID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).meHintCountsPerBlock as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(meHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).meExternalHints as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(meExternalHints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).reserved1 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).reserved2 as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_MEONLY_PARAMS"]
#[doc = " MEOnly parameters that need to be sent on a per motion estimation basis."]
#[doc = " NV_ENC_MEONLY_PARAMS::meExternalHints is supported for H264 only."]
pub type NV_ENC_MEONLY_PARAMS = _NV_ENC_MEONLY_PARAMS;
#[doc = " \\struct _NV_ENC_LOCK_BITSTREAM"]
#[doc = " Bitstream buffer lock parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_LOCK_BITSTREAM {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_LOCK_BITSTREAM_VER."]
    pub version: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]: Pointer to the bitstream buffer being locked."]
    pub outputBitstream: *mut ::std::os::raw::c_void,
    #[doc = "< [in, out]: Array which receives the slice offsets. This is not supported if NV_ENC_CONFIG_H264::sliceMode is 1 on Kepler GPUs. Array size must be equal to size of frame in MBs."]
    pub sliceOffsets: *mut u32,
    #[doc = "< [out]: Frame no. for which the bitstream is being retrieved."]
    pub frameIdx: u32,
    #[doc = "< [out]: The NvEncodeAPI interface status for the locked picture."]
    pub hwEncodeStatus: u32,
    #[doc = "< [out]: Number of slices in the encoded picture. Will be reported only if NV_ENC_INITIALIZE_PARAMS::reportSliceOffsets set to 1."]
    pub numSlices: u32,
    #[doc = "< [out]: Actual number of bytes generated and copied to the memory pointed by bitstreamBufferPtr."]
    #[doc = "When HEVC alpha layer encoding is enabled, this field reports the total encoded size in bytes i.e it is the encoded size of the base plus the alpha layer."]
    pub bitstreamSizeInBytes: u32,
    #[doc = "< [out]: Presentation timestamp associated with the encoded output."]
    pub outputTimeStamp: u64,
    #[doc = "< [out]: Presentation duration associates with the encoded output."]
    pub outputDuration: u64,
    #[doc = "< [out]: Pointer to the generated output bitstream."]
    #[doc = "For MEOnly mode _NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr should be typecast to"]
    #[doc = "NV_ENC_H264_MV_DATA/NV_ENC_HEVC_MV_DATA pointer respectively for H264/HEVC"]
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Picture type of the encoded picture."]
    pub pictureType: NV_ENC_PIC_TYPE,
    #[doc = "< [out]: Structure of the generated output picture."]
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    #[doc = "< [out]: Average QP of the frame."]
    pub frameAvgQP: u32,
    #[doc = "< [out]: Total SATD cost for whole frame."]
    pub frameSatd: u32,
    #[doc = "< [out]: Frame index associated with this LTR frame."]
    pub ltrFrameIdx: u32,
    #[doc = "< [out]: Bitmap of LTR frames indices which were used for encoding this frame. Value of 0 if no LTR frames were used."]
    pub ltrFrameBitmap: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 13usize],
    #[doc = "< [out]: For H264, Number of Intra MBs in the encoded frame. For HEVC, Number of Intra CTBs in the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub intraMBCount: u32,
    #[doc = "< [out]: For H264, Number of Inter MBs in the encoded frame, includes skip MBs. For HEVC, Number of Inter CTBs in the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub interMBCount: u32,
    #[doc = "< [out]: Average Motion Vector in X direction for the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub averageMVX: i32,
    #[doc = "< [out]: Average Motion Vector in y direction for the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub averageMVY: i32,
    #[doc = "< [out]: Number of bytes generated for the alpha layer in the encoded output. Applicable only when HEVC with alpha encoding is enabled."]
    pub alphaLayerSizeInBytes: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 218usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_LOCK_BITSTREAM() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_LOCK_BITSTREAM>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_LOCK_BITSTREAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_LOCK_BITSTREAM>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_LOCK_BITSTREAM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).outputBitstream as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).sliceOffsets as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(sliceOffsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).frameIdx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).hwEncodeStatus as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(hwEncodeStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).numSlices as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).bitstreamSizeInBytes as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(bitstreamSizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).outputTimeStamp as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputTimeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).outputDuration as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputDuration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).bitstreamBufferPtr as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(bitstreamBufferPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).pictureType as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(pictureType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).pictureStruct as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(pictureStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).frameAvgQP as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameAvgQP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).frameSatd as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameSatd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).ltrFrameIdx as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(ltrFrameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).ltrFrameBitmap as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(ltrFrameBitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).reserved as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).intraMBCount as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(intraMBCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).interMBCount as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(interMBCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).averageMVX as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(averageMVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).averageMVY as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(averageMVY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).alphaLayerSizeInBytes as *const _
                as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(alphaLayerSizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).reserved1 as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).reserved2 as *const _ as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_LOCK_BITSTREAM {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn getRCStats(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_getRCStats(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        ltrFrame: u32,
        getRCStats: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::std::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let getRCStats: u32 = unsafe { ::std::mem::transmute(getRCStats) };
            getRCStats as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_LOCK_BITSTREAM"]
#[doc = " Bitstream buffer lock parameters."]
pub type NV_ENC_LOCK_BITSTREAM = _NV_ENC_LOCK_BITSTREAM;
#[doc = " \\struct _NV_ENC_LOCK_INPUT_BUFFER"]
#[doc = " Uncompressed Input Buffer lock parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_LOCK_INPUT_BUFFER {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_LOCK_INPUT_BUFFER_VER."]
    pub version: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]:  Pointer to the input buffer to be locked, client should pass the pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource API."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [out]: Pointed to the locked input buffer data. Client can only access input buffer using the \\p bufferDataPtr."]
    pub bufferDataPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Pitch of the locked input buffer."]
    pub pitch: u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved1: [u32; 251usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_LOCK_INPUT_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_LOCK_INPUT_BUFFER>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_LOCK_INPUT_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_LOCK_INPUT_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_LOCK_INPUT_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).inputBuffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).bufferDataPtr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(bufferDataPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).pitch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).reserved1 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).reserved2 as *const _ as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_LOCK_INPUT_BUFFER {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_LOCK_INPUT_BUFFER"]
#[doc = " Uncompressed Input Buffer lock parameters."]
pub type NV_ENC_LOCK_INPUT_BUFFER = _NV_ENC_LOCK_INPUT_BUFFER;
#[doc = " \\struct _NV_ENC_MAP_INPUT_RESOURCE"]
#[doc = " Map an input resource to a Nvidia Encoder Input Buffer"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_MAP_INPUT_RESOURCE {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_MAP_INPUT_RESOURCE_VER."]
    pub version: u32,
    #[doc = "< [in]:  Deprecated. Do not use."]
    pub subResourceIndex: u32,
    #[doc = "< [in]:  Deprecated. Do not use."]
    pub inputResource: *mut ::std::os::raw::c_void,
    #[doc = "< [in]:  The Registered resource handle obtained by calling NvEncRegisterInputResource."]
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    #[doc = "< [out]: Mapped pointer corresponding to the registeredResource. This pointer must be used in NV_ENC_PIC_PARAMS::inputBuffer parameter in ::NvEncEncodePicture() API."]
    pub mappedResource: NV_ENC_INPUT_PTR,
    #[doc = "< [out]: Buffer format of the outputResource. This buffer format must be used in NV_ENC_PIC_PARAMS::bufferFmt if client using the above mapped resource pointer."]
    pub mappedBufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]:  Reserved and must be set to 0."]
    pub reserved1: [u32; 251usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_MAP_INPUT_RESOURCE() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_MAP_INPUT_RESOURCE>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_MAP_INPUT_RESOURCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_MAP_INPUT_RESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MAP_INPUT_RESOURCE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).subResourceIndex as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(subResourceIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).inputResource as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(inputResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).registeredResource as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(registeredResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).mappedResource as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(mappedResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).mappedBufferFmt as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(mappedBufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).reserved1 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).reserved2 as *const _ as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_MAP_INPUT_RESOURCE"]
#[doc = " Map an input resource to a Nvidia Encoder Input Buffer"]
pub type NV_ENC_MAP_INPUT_RESOURCE = _NV_ENC_MAP_INPUT_RESOURCE;
#[doc = " \\struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX"]
#[doc = " NV_ENC_REGISTER_RESOURCE::resourceToRegister must be a pointer to a variable of this type,"]
#[doc = " when NV_ENC_REGISTER_RESOURCE::resourceType is NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX"]
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX {
    #[doc = "< [in]: The name of the texture to be used."]
    pub texture: u32,
    #[doc = "< [in]: Accepted values are GL_TEXTURE_RECTANGLE and GL_TEXTURE_2D."]
    pub target: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_INPUT_RESOURCE_OPENGL_TEX() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>())).texture as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>())).target as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX),
            "::",
            stringify!(target)
        )
    );
}
#[doc = " \\struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX"]
#[doc = " NV_ENC_REGISTER_RESOURCE::resourceToRegister must be a pointer to a variable of this type,"]
#[doc = " when NV_ENC_REGISTER_RESOURCE::resourceType is NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX"]
pub type NV_ENC_INPUT_RESOURCE_OPENGL_TEX = _NV_ENC_INPUT_RESOURCE_OPENGL_TEX;
#[doc = " \\struct _NV_ENC_REGISTER_RESOURCE"]
#[doc = " Register a resource for future use with the Nvidia Video Encoder Interface."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_REGISTER_RESOURCE {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_REGISTER_RESOURCE_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the type of resource to be registered."]
    #[doc = "Supported values are"]
    #[doc = "::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX,"]
    #[doc = "::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR,"]
    #[doc = "::NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX"]
    pub resourceType: NV_ENC_INPUT_RESOURCE_TYPE,
    #[doc = "< [in]: Input frame width."]
    pub width: u32,
    #[doc = "< [in]: Input frame height."]
    pub height: u32,
    #[doc = "< [in]: Input buffer pitch."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX resources, set this to 0."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR resources, set this to"]
    #[doc = "the pitch as obtained from cuMemAllocPitch(), or to the width in"]
    #[doc = "bytes (if this resource was created by using cuMemAlloc()). This"]
    #[doc = "value must be a multiple of 4."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY resources, set this to the"]
    #[doc = "width of the allocation in bytes (i.e."]
    #[doc = "CUDA_ARRAY3D_DESCRIPTOR::Width * CUDA_ARRAY3D_DESCRIPTOR::NumChannels)."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX resources, set this to the"]
    #[doc = "texture width multiplied by the number of components in the texture"]
    #[doc = "format."]
    pub pitch: u32,
    #[doc = "< [in]: Subresource Index of the DirectX resource to be registered. Should be set to 0 for other interfaces."]
    pub subResourceIndex: u32,
    #[doc = "< [in]: Handle to the resource that is being registered."]
    pub resourceToRegister: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Registered resource handle. This should be used in future interactions with the Nvidia Video Encoder Interface."]
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    #[doc = "< [in]: Buffer format of resource to be registered."]
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Usage of resource to be registered."]
    pub bufferUsage: NV_ENC_BUFFER_USAGE,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 247usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 62usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_REGISTER_RESOURCE() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_REGISTER_RESOURCE>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_REGISTER_RESOURCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_REGISTER_RESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_REGISTER_RESOURCE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).resourceType as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(resourceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).height as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).pitch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).subResourceIndex as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(subResourceIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).resourceToRegister as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(resourceToRegister)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).registeredResource as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(registeredResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).bufferFormat as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(bufferFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).bufferUsage as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(bufferUsage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).reserved1 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).reserved2 as *const _ as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_REGISTER_RESOURCE"]
#[doc = " Register a resource for future use with the Nvidia Video Encoder Interface."]
pub type NV_ENC_REGISTER_RESOURCE = _NV_ENC_REGISTER_RESOURCE;
#[doc = " \\struct _NV_ENC_STAT"]
#[doc = " Encode Stats structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_STAT {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_STAT_VER."]
    pub version: u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Specifies the pointer to output bitstream."]
    pub outputBitStream: NV_ENC_OUTPUT_PTR,
    #[doc = "< [out]: Size of generated bitstream in bytes."]
    pub bitStreamSize: u32,
    #[doc = "< [out]: Picture type of encoded picture. See ::NV_ENC_PIC_TYPE."]
    pub picType: u32,
    #[doc = "< [out]: Offset of last valid bytes of completed bitstream"]
    pub lastValidByteOffset: u32,
    #[doc = "< [out]: Offsets of each slice"]
    pub sliceOffsets: [u32; 16usize],
    #[doc = "< [out]: Picture number"]
    pub picIdx: u32,
    #[doc = "< [out]: Average QP of the frame."]
    pub frameAvgQP: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [out]: Frame index associated with this LTR frame."]
    pub ltrFrameIdx: u32,
    #[doc = "< [out]: For H264, Number of Intra MBs in the encoded frame. For HEVC, Number of Intra CTBs in the encoded frame."]
    pub intraMBCount: u32,
    #[doc = "< [out]: For H264, Number of Inter MBs in the encoded frame, includes skip MBs. For HEVC, Number of Inter CTBs in the encoded frame."]
    pub interMBCount: u32,
    #[doc = "< [out]: Average Motion Vector in X direction for the encoded frame."]
    pub averageMVX: i32,
    #[doc = "< [out]: Average Motion Vector in y direction for the encoded frame."]
    pub averageMVY: i32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved1: [u32; 226usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_STAT() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_STAT>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_STAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_STAT>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_STAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).outputBitStream as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(outputBitStream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).bitStreamSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(bitStreamSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).picType as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(picType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_STAT>())).lastValidByteOffset as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(lastValidByteOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).sliceOffsets as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(sliceOffsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).picIdx as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(picIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).frameAvgQP as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(frameAvgQP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).ltrFrameIdx as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(ltrFrameIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).intraMBCount as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(intraMBCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).interMBCount as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(interMBCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).averageMVX as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(averageMVX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).averageMVY as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(averageMVY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).reserved1 as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).reserved2 as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_STAT {
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ltrFrame: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::std::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_STAT"]
#[doc = " Encode Stats structure."]
pub type NV_ENC_STAT = _NV_ENC_STAT;
#[doc = " \\struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD"]
#[doc = " Sequence and picture paramaters payload."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_INITIALIZE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]:  Specifies the size of the spsppsBuffer provided by the client"]
    pub inBufferSize: u32,
    #[doc = "< [in]:  Specifies the SPS id to be used in sequence header. Default value is 0."]
    pub spsId: u32,
    #[doc = "< [in]:  Specifies the PPS id to be used in picture header. Default value is 0."]
    pub ppsId: u32,
    #[doc = "< [in]:  Specifies bitstream header pointer of size NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize."]
    #[doc = "It is the client's responsibility to manage this memory."]
    pub spsppsBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Size of the sequence and picture header in bytes."]
    pub outSPSPPSPayloadSize: *mut u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved: [u32; 250usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_SEQUENCE_PARAM_PAYLOAD() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).inBufferSize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(inBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).spsId as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).ppsId as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).spsppsBuffer as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(spsppsBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).outSPSPPSPayloadSize
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(outSPSPPSPayloadSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).reserved as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).reserved2 as *const _
                as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD"]
#[doc = " Sequence and picture paramaters payload."]
pub type NV_ENC_SEQUENCE_PARAM_PAYLOAD = _NV_ENC_SEQUENCE_PARAM_PAYLOAD;
#[doc = " Event registration/unregistration parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_EVENT_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_EVENT_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [in]: Handle to event to be registered/unregistered with the NvEncodeAPI interface."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 253usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_EVENT_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_EVENT_PARAMS>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_EVENT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_EVENT_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_EVENT_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).completionEvent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).reserved1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).reserved2 as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Event registration/unregistration parameters."]
pub type NV_ENC_EVENT_PARAMS = _NV_ENC_EVENT_PARAMS;
#[doc = " Encoder Session Creation parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specified the device Type"]
    pub deviceType: NV_ENC_DEVICE_TYPE,
    #[doc = "< [in]: Pointer to client device."]
    pub device: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: API version. Should be set to NVENCAPI_VERSION."]
    pub apiVersion: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 253usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>(),
        1552usize,
        concat!(
            "Size of: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).deviceType as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(deviceType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).device as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).reserved as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).apiVersion as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(apiVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).reserved1 as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).reserved2 as *const _
                as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Encoder Session Creation parameters"]
pub type NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS = _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS;
extern "C" {
    #[doc = " \\brief Get the largest NvEncodeAPI version supported by the driver."]
    #[doc = ""]
    #[doc = " This function can be used by clients to determine if the driver supports"]
    #[doc = " the NvEncodeAPI header the application was compiled with."]
    #[doc = ""]
    #[doc = " \\param [out] version"]
    #[doc = "   Pointer to the requested value. The 4 least significant bits in the returned"]
    #[doc = "   indicate the minor version and the rest of the bits indicate the major"]
    #[doc = "   version of the largest supported version."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    pub fn NvEncodeAPIGetMaxSupportedVersion(version: *mut u32) -> NVENCSTATUS;
}
#[doc = " \\cond API PFN"]
pub type PNVENCOPENENCODESESSION = ::std::option::Option<
    unsafe extern "C" fn(
        device: *mut ::std::os::raw::c_void,
        deviceType: u32,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPROFILEGUIDCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodeProfileGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPROFILEGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        profileGUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODECAPS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::std::os::raw::c_int,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIG = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIGEX = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        tuningInfo: NV_ENC_TUNING_INFO::Type,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCINITIALIZEENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCENCODEPICTURE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODESTATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYENCODER = ::std::option::Option<
    unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> NVENCSTATUS,
>;
pub type PNVENCINVALIDATEREFFRAMES = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS,
>;
pub type PNVENCOPENENCODESESSIONEX = ::std::option::Option<
    unsafe extern "C" fn(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registeredRes: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRECONFIGUREENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRUNMOTIONESTIMATIONONLY = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETLASTERROR = ::std::option::Option<
    unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
>;
pub type PNVENCSETIOCUDASTREAMS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMEX = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encInitParams: *mut NV_ENC_INITIALIZE_PARAMS,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
#[doc = " \\ingroup ENCODER_STRUCTURE"]
#[doc = " NV_ENCODE_API_FUNCTION_LIST"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENCODE_API_FUNCTION_LIST {
    #[doc = "< [in]: Client should pass NV_ENCODE_API_FUNCTION_LIST_VER."]
    pub version: u32,
    #[doc = "< [in]: Reserved and should be set to 0."]
    pub reserved: u32,
    #[doc = "< [out]: Client should access ::NvEncOpenEncodeSession() API through this pointer."]
    pub nvEncOpenEncodeSession: PNVENCOPENENCODESESSION,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeGUIDCount() API through this pointer."]
    pub nvEncGetEncodeGUIDCount: PNVENCGETENCODEGUIDCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeProfileGUIDCount() API through this pointer."]
    pub nvEncGetEncodeProfileGUIDCount: PNVENCGETENCODEPRESETCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeProfileGUIDs() API through this pointer."]
    pub nvEncGetEncodeProfileGUIDs: PNVENCGETENCODEPRESETGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeGUIDs() API through this pointer."]
    pub nvEncGetEncodeGUIDs: PNVENCGETENCODEGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetInputFormatCount() API through this pointer."]
    pub nvEncGetInputFormatCount: PNVENCGETINPUTFORMATCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetInputFormats() API through this pointer."]
    pub nvEncGetInputFormats: PNVENCGETINPUTFORMATS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeCaps() API through this pointer."]
    pub nvEncGetEncodeCaps: PNVENCGETENCODECAPS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetCount() API through this pointer."]
    pub nvEncGetEncodePresetCount: PNVENCGETENCODEPRESETCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetGUIDs() API through this pointer."]
    pub nvEncGetEncodePresetGUIDs: PNVENCGETENCODEPRESETGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetConfig() API through this pointer."]
    pub nvEncGetEncodePresetConfig: PNVENCGETENCODEPRESETCONFIG,
    #[doc = "< [out]: Client should access ::NvEncInitializeEncoder() API through this pointer."]
    pub nvEncInitializeEncoder: PNVENCINITIALIZEENCODER,
    #[doc = "< [out]: Client should access ::NvEncCreateInputBuffer() API through this pointer."]
    pub nvEncCreateInputBuffer: PNVENCCREATEINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyInputBuffer() API through this pointer."]
    pub nvEncDestroyInputBuffer: PNVENCDESTROYINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncCreateBitstreamBuffer() API through this pointer."]
    pub nvEncCreateBitstreamBuffer: PNVENCCREATEBITSTREAMBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyBitstreamBuffer() API through this pointer."]
    pub nvEncDestroyBitstreamBuffer: PNVENCDESTROYBITSTREAMBUFFER,
    #[doc = "< [out]: Client should access ::NvEncEncodePicture() API through this pointer."]
    pub nvEncEncodePicture: PNVENCENCODEPICTURE,
    #[doc = "< [out]: Client should access ::NvEncLockBitstream() API through this pointer."]
    pub nvEncLockBitstream: PNVENCLOCKBITSTREAM,
    #[doc = "< [out]: Client should access ::NvEncUnlockBitstream() API through this pointer."]
    pub nvEncUnlockBitstream: PNVENCUNLOCKBITSTREAM,
    #[doc = "< [out]: Client should access ::NvEncLockInputBuffer() API through this pointer."]
    pub nvEncLockInputBuffer: PNVENCLOCKINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncUnlockInputBuffer() API through this pointer."]
    pub nvEncUnlockInputBuffer: PNVENCUNLOCKINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeStats() API through this pointer."]
    pub nvEncGetEncodeStats: PNVENCGETENCODESTATS,
    #[doc = "< [out]: Client should access ::NvEncGetSequenceParams() API through this pointer."]
    pub nvEncGetSequenceParams: PNVENCGETSEQUENCEPARAMS,
    #[doc = "< [out]: Client should access ::NvEncRegisterAsyncEvent() API through this pointer."]
    pub nvEncRegisterAsyncEvent: PNVENCREGISTERASYNCEVENT,
    #[doc = "< [out]: Client should access ::NvEncUnregisterAsyncEvent() API through this pointer."]
    pub nvEncUnregisterAsyncEvent: PNVENCUNREGISTERASYNCEVENT,
    #[doc = "< [out]: Client should access ::NvEncMapInputResource() API through this pointer."]
    pub nvEncMapInputResource: PNVENCMAPINPUTRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncUnmapInputResource() API through this pointer."]
    pub nvEncUnmapInputResource: PNVENCUNMAPINPUTRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncDestroyEncoder() API through this pointer."]
    pub nvEncDestroyEncoder: PNVENCDESTROYENCODER,
    #[doc = "< [out]: Client should access ::NvEncInvalidateRefFrames() API through this pointer."]
    pub nvEncInvalidateRefFrames: PNVENCINVALIDATEREFFRAMES,
    #[doc = "< [out]: Client should access ::NvEncOpenEncodeSession() API through this pointer."]
    pub nvEncOpenEncodeSessionEx: PNVENCOPENENCODESESSIONEX,
    #[doc = "< [out]: Client should access ::NvEncRegisterResource() API through this pointer."]
    pub nvEncRegisterResource: PNVENCREGISTERRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncUnregisterResource() API through this pointer."]
    pub nvEncUnregisterResource: PNVENCUNREGISTERRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncReconfigureEncoder() API through this pointer."]
    pub nvEncReconfigureEncoder: PNVENCRECONFIGUREENCODER,
    pub reserved1: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Client should access ::NvEncCreateMVBuffer API through this pointer."]
    pub nvEncCreateMVBuffer: PNVENCCREATEMVBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyMVBuffer API through this pointer."]
    pub nvEncDestroyMVBuffer: PNVENCDESTROYMVBUFFER,
    #[doc = "< [out]: Client should access ::NvEncRunMotionEstimationOnly API through this pointer."]
    pub nvEncRunMotionEstimationOnly: PNVENCRUNMOTIONESTIMATIONONLY,
    #[doc = "< [out]: Client should access ::nvEncGetLastErrorString API through this pointer."]
    pub nvEncGetLastErrorString: PNVENCGETLASTERROR,
    #[doc = "< [out]: Client should access ::nvEncSetIOCudaStreams API through this pointer."]
    pub nvEncSetIOCudaStreams: PNVENCSETIOCUDASTREAMS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetConfigEx() API through this pointer."]
    pub nvEncGetEncodePresetConfigEx: PNVENCGETENCODEPRESETCONFIGEX,
    #[doc = "< [out]: Client should access ::NvEncGetSequenceParamEx() API through this pointer."]
    pub nvEncGetSequenceParamEx: PNVENCGETSEQUENCEPARAMEX,
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 277usize],
}
#[test]
fn bindgen_test_layout__NV_ENCODE_API_FUNCTION_LIST() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENCODE_API_FUNCTION_LIST>(),
        2552usize,
        concat!("Size of: ", stringify!(_NV_ENCODE_API_FUNCTION_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENCODE_API_FUNCTION_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENCODE_API_FUNCTION_LIST))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncOpenEncodeSession
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncOpenEncodeSession)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeGUIDCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeGUIDCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeProfileGUIDCount
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeProfileGUIDCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeProfileGUIDs
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeProfileGUIDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeGUIDs as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeGUIDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetInputFormatCount
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetInputFormatCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetInputFormats
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetInputFormats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeCaps as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeCaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodePresetCount
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodePresetGUIDs
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetGUIDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodePresetConfig
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncInitializeEncoder
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncInitializeEncoder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncCreateInputBuffer
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyInputBuffer
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncCreateBitstreamBuffer
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateBitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyBitstreamBuffer
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyBitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncEncodePicture as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncEncodePicture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncLockBitstream as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncLockBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnlockBitstream
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnlockBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncLockInputBuffer
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncLockInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnlockInputBuffer
                as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnlockInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeStats as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeStats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetSequenceParams
                as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetSequenceParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncRegisterAsyncEvent
                as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRegisterAsyncEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnregisterAsyncEvent
                as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnregisterAsyncEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncMapInputResource
                as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncMapInputResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnmapInputResource
                as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnmapInputResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyEncoder as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyEncoder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncInvalidateRefFrames
                as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncInvalidateRefFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncOpenEncodeSessionEx
                as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncOpenEncodeSessionEx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncRegisterResource
                as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRegisterResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnregisterResource
                as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnregisterResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncReconfigureEncoder
                as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncReconfigureEncoder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).reserved1 as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncCreateMVBuffer as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateMVBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyMVBuffer
                as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyMVBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncRunMotionEstimationOnly
                as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRunMotionEstimationOnly)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetLastErrorString
                as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetLastErrorString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncSetIOCudaStreams
                as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncSetIOCudaStreams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodePresetConfigEx
                as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetConfigEx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetSequenceParamEx
                as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetSequenceParamEx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).reserved2 as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\ingroup ENCODER_STRUCTURE"]
#[doc = " NV_ENCODE_API_FUNCTION_LIST"]
pub type NV_ENCODE_API_FUNCTION_LIST = _NV_ENCODE_API_FUNCTION_LIST;
extern "C" {
    #[doc = " \\ingroup ENCODE_FUNC"]
    #[doc = " Entry Point to the NvEncodeAPI interface."]
    #[doc = ""]
    #[doc = " Creates an instance of the NvEncodeAPI interface, and populates the"]
    #[doc = " pFunctionList with function pointers to the API routines implemented by the"]
    #[doc = " NvEncodeAPI interface."]
    #[doc = ""]
    #[doc = " \\param [out] functionList"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR"]
    pub fn NvEncodeAPICreateInstance(functionList: *mut NV_ENCODE_API_FUNCTION_LIST)
        -> NVENCSTATUS;
}
pub const NVENCAPI_VERSION: u32 = 11;
pub const NV_ENC_CAPS_PARAM_VER: u32 = 1879113739;
pub const NV_ENC_CREATE_INPUT_BUFFER_VER: u32 = 1879113739;
pub const NV_ENC_CREATE_BITSTREAM_BUFFER_VER: u32 = 1879113739;
pub const NV_ENC_CREATE_MV_BUFFER_VER: u32 = 1879113739;
pub const NV_ENC_RC_PARAMS_VER: u32 = 1879113739;
pub const NV_ENC_CONFIG_VER: u32 = 4026990603;
pub const NV_ENC_INITIALIZE_PARAMS_VER: u32 = 4026859531;
pub const NV_ENC_RECONFIGURE_PARAMS_VER: u32 = 4026597387;
pub const NV_ENC_PRESET_CONFIG_VER: u32 = 4026793995;
pub const NV_ENC_PIC_PARAMS_VER: u32 = 4026793995;
pub const NV_ENC_MEONLY_PARAMS_VER: u32 = 1879244811;
pub const NV_ENC_LOCK_BITSTREAM_VER: u32 = 1879113739;
pub const NV_ENC_LOCK_INPUT_BUFFER_VER: u32 = 1879113739;
pub const NV_ENC_MAP_INPUT_RESOURCE_VER: u32 = 1879310347;
pub const NV_ENC_REGISTER_RESOURCE_VER: u32 = 1879244811;
pub const NV_ENC_STAT_VER: u32 = 1879113739;
pub const NV_ENC_SEQUENCE_PARAM_PAYLOAD_VER: u32 = 1879113739;
pub const NV_ENC_EVENT_PARAMS_VER: u32 = 1879113739;
pub const NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER: u32 = 1879113739;
pub const NV_ENCODE_API_FUNCTION_LIST_VER: u32 = 1879179275;
